<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sansan.blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-09T01:43:39.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>三三</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>各种页面常见布局整理</title>
    <link href="http://yoursite.com/2018/04/08/%E5%90%84%E7%A7%8D%E9%A1%B5%E9%9D%A2%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/08/各种页面常见布局整理/</id>
    <published>2018-04-08T01:27:46.000Z</published>
    <updated>2018-04-09T01:43:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><b>对各种页面常见布局比如水平垂直居中、两列布局、多列布局的实现原理、实现方法、优缺点做了简单整理。</b><br><a id="more"></a></p>
<h1 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h1><h2 id="文本元素-行内元素-行内块级元素"><a href="#文本元素-行内元素-行内块级元素" class="headerlink" title="文本元素/行内元素/行内块级元素"></a>文本元素/行内元素/行内块级元素</h2><p>原理：text-align只控制行内内容(文字、行内元素、行内块级元素)如何相对他的块父元素对齐<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优点：简单快捷，容易理解，兼容性非常好；<br>缺点：只对行内内容有效；属性会继承影响到后代行内内容；如果子元素宽度大于父元素宽度则无效，只有后代行内内容中宽度小于设置text-align属性的元素宽度的时候，才会水平居中。</p>
<h2 id="单个块级元素"><a href="#单个块级元素" class="headerlink" title="单个块级元素"></a>单个块级元素</h2><p>原理：有这么一种情况：在margin有节余的同时如果左右margin设置了auto，将会均分剩余空间。另外，如果上下的margin设置了auto，其计算值为0。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#son</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; <span class="comment">/*必须定宽*/</span></div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优点：简单；兼容性好；<br>缺点：必须定宽，并且值不能为auto；宽度要小于父元素，否则无效。</p>
<h2 id="多个块级元素"><a href="#多个块级元素" class="headerlink" title="多个块级元素"></a>多个块级元素</h2><p>原理：text-align只控制行内内容(文字、行内元素、行内块级元素)如何相对他的块父元素对齐<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#parent</span> &#123;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.son</span> &#123;</div><div class="line">    <span class="attribute">display</span>: inline-block; <span class="comment">/*改为行内或者行内块级形式，以达到text-align对其生效*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优点：简单，容易理解，兼容性非常好；<br>缺点：只对行内内容有效；属性会继承影响到后代行内内容；块级改为inline-block换行、空格会产生元素间隔。</p>
<h2 id="使用绝对定位实现"><a href="#使用绝对定位实现" class="headerlink" title="使用绝对定位实现"></a>使用绝对定位实现</h2><p>原理：子绝父相，top、right、bottom、left的值是相对于父元素尺寸的，然后margin或者transform是相对于自身尺寸的，组合使用达到水平居中的目的<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line"> &#125;</div><div class="line"> <span class="selector-class">.son</span> &#123;</div><div class="line">     <span class="attribute">position</span>: absolute;</div><div class="line">     <span class="comment">/*width: 100px;  !*定宽*!*/</span></div><div class="line">     <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">     <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50%);<span class="comment">/*自身宽度一半,等同于margin-left: -50px;*/</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>优点：使用margin-left兼容性好；不管是块级还是行内元素都可以实现;<br>缺点：代码较多；脱离文档流；使用margin-left需要知道宽度值；使用transform兼容性不好（ie9+）</p>
<h2 id="任意个元素-flex"><a href="#任意个元素-flex" class="headerlink" title="任意个元素(flex)"></a>任意个元素(flex)</h2><p>原理：就是设置当前主轴对齐方式为居中。说不上为什么，flex无非就是主轴侧轴是重点，然后就是排列方式的设置<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.parent</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="attribute">justify-content</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优点：功能强大；简单方便；容易理解；<br>缺点：PC端兼容性不好，移动端（Android4.0+）。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>对于水平居中，我们应该先考虑，哪些元素有自带的居中效果，最先想到的应该就是 text-align:center 了，但是这个只对行内内容有效，所以我们要使用 text-align:center 就必须将子元素设置为 display: inline; 或者 display: inline-block; ；</li>
<li>其次就是考虑能不能用margin: 0 auto; ，因为这都是一两句代码能搞定的事，实在不行就是用绝对定位去实现了。</li>
<li>移动端能用flex就用flex，简单方便，灵活并且功能强大，无愧为网页布局的一大利器！</li>
</ul>
<h1 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h1><h2 id="单行文本-行内元素-行内块级元素"><a href="#单行文本-行内元素-行内块级元素" class="headerlink" title="单行文本/行内元素/行内块级元素"></a>单行文本/行内元素/行内块级元素</h2><p>原理：line-height的最终表现是通过inline box实现的，而无论inline box所占据的高度是多少（无论比文字大还是比文字小），其占据的空间都是与文字内容公用水平中垂线的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#parent</span>&#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">150px</span>;  <span class="comment">/*与height等值*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优点：简单；兼容性好；<br>缺点：只能用于单行行内内容；要知道高度的值。</p>
<h2 id="多行文本-行内元素-行内块级元素"><a href="#多行文本-行内元素-行内块级元素" class="headerlink" title="多行文本/行内元素/行内块级元素"></a>多行文本/行内元素/行内块级元素</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#parent</span>&#123;  <span class="comment">/*或者用span把所有文字包裹起来，设置display：inline-block转换成图片的方式解决*/</span></div><div class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;  <span class="comment">/*元素在页面呈现为5行,则line-height的值为height/5*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：简单；兼容性好；<br>缺点：只能用于行内内容；需要知道高度和最终呈现多少行来计算出line-height的值，建议用span包裹多行文本。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#parent</span>&#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">150px</span>;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">img</span><span class="selector-id">#son</span>&#123;<span class="attribute">vertical-align</span>: middle;&#125; <span class="comment">/*默认是基线对齐，改为middle*/</span></div></pre></td></tr></table></figure>
<p>优点：简单；兼容性好；<br>缺点：需要添加font-size: 0; 才可以完全的垂直居中；不过需要主要，html#parent包裹img之间需要有换行或空格。</p>
<h2 id="单个块级元素-1"><a href="#单个块级元素-1" class="headerlink" title="单个块级元素"></a>单个块级元素</h2><h3 id="使用tabel-cell实现"><a href="#使用tabel-cell实现" class="headerlink" title="使用tabel-cell实现"></a>使用tabel-cell实现</h3><p>原理：CSS Table，使表格内容对齐方式为middle<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#parent</span> &#123;</div><div class="line">    <span class="attribute">display</span>: table-cell;</div><div class="line">    <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>优点：简单；宽高不定；兼容性好（ie8+）<br>缺点：设置tabl-cell的元素，宽度和高度的值设置百分比无效，需要给它的父元素设置display: table; 才生效；table-cell不感知margin，在父元素上设置table-row等属性，也会使其不感知height；设置float或position会对默认布局造成破坏，可以考虑为之增加一个父div定义float等属性；内容溢出时会自动撑开父元素</p>
<p>### </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;对各种页面常见布局比如水平垂直居中、两列布局、多列布局的实现原理、实现方法、优缺点做了简单整理。&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>chrome开发者工具整理</title>
    <link href="http://yoursite.com/2018/04/03/chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/03/chrome开发者工具整理/</id>
    <published>2018-04-03T06:06:30.000Z</published>
    <updated>2018-04-09T01:40:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><b>在前端的日常开发上，经常会使用到chrome浏览器的开发者工具，在下面对chrome开发者工具各个面板的功能做了简单的整理。</b><br><a id="more"></a></p>
<h1 id="element"><a href="#element" class="headerlink" title="element"></a>element</h1><p>切图调整样式的时候经常用到：</p>
<ol>
<li>快速选择元素</li>
<li>移动端适配模式，适配各种机型</li>
<li>快速查看被选择元素的所有的涉及样式</li>
<li>快速查找被选择元素的事件</li>
<li>元素状态筛选：hover、focus、active、visited</li>
<li>css3动画曲线调试</li>
</ol>
<h1 id="console"><a href="#console" class="headerlink" title="console"></a>console</h1><p>JS调试代码时经常需要console输出变量或者节点：</p>
<ol>
<li>console.log输出变量（console.info,console.warn,console.error）</li>
<li><p>console.time和console.timeEnd<br>主要是检测一段代码的执行时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.time();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.timeEnd();</div></pre></td></tr></table></figure>
</li>
<li><p>console.table<br>更直观的显示对象或数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="built_in">console</span>.table(arr1)</div></pre></td></tr></table></figure>
</li>
<li><p>console.count<br>在调试代码时，判断一个代码的执行次数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.count()</div><div class="line">    &#125;;</div><div class="line">    fn();</div><div class="line">    fn();</div></pre></td></tr></table></figure>
</li>
<li><p>console.assert<br>console.assert接收两个参数，第一个参数为判断条件，第二个参数是提示信息，当条件为false时，提示错误信息！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.assert(flag, <span class="string">'error'</span>);</div><div class="line"><span class="keyword">let</span> flags = <span class="literal">false</span>;</div><div class="line"><span class="built_in">console</span>.assert(flags, <span class="string">'success'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>console.group和console.groupEnd</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.group(<span class="string">"1"</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"1模块的信息 11111111..."</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"1模块的信息 11111111..."</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"1模块的信息 11111111..."</span>);</div><div class="line"><span class="built_in">console</span>.groupEnd();</div></pre></td></tr></table></figure>
</li>
<li><p>$(浏览器自带的API)</p>
</li>
</ol>
<ul>
<li>$:返回第一个符合条件的元素，相当于document.querySelector<br>在浏览器的console上输入：$(‘button’)</li>
<li>$$:返回所有符合条件的元素，相当于document.querySelectorAll<br>在浏览器的console上输入：$(‘li’)</li>
</ul>
<ol>
<li>查找和监控事件</li>
</ol>
<ul>
<li><p>getEventListeners作用就是查找并获取选定元素的事件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getEventListeners($(<span class="string">'#one'</span>));</div></pre></td></tr></table></figure>
</li>
<li><p>monitorEvents作用是监控你所选元素关联的所有事件，事件触发时，在控制台打印它们:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">monitorEvents($(<span class="string">'#one'</span>));</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="network"><a href="#network" class="headerlink" title="network"></a>network</h1><p>每当有请求发送的时候，都会被这里记录,可以查看请求的详细信息。</p>
<h1 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h1><ol>
<li>断点调试<br>打开文件，在任意一行的行号，点击就会出现一个断点</li>
<li>debugger调试<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">debugger</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>调试栏的六个按钮作用分别为：<br>1、停止当前的断点调试<br>2、继续执行下一行代码，（1.这个方式不会进入函数，2.这个方式快捷键是f10）<br>3、跳入函数中去（这个方式快捷键是f11）<br>4、跳出当前的函数<br>5、禁用所有的断点，停止任何调试<br>6、程序运行时遇到异常时是否中断调试</p>
<ol>
<li>调试中查看值<br>鼠标移到上方即可查看变量值</li>
<li>查找和切换文件<br>ctrl+p和enter快捷键</li>
<li>格式化代码<br>左下角的{}</li>
</ol>
<h1 id="performance-timeline"><a href="#performance-timeline" class="headerlink" title="performance(timeline)"></a>performance(timeline)</h1><p>这个面板后期优化的时候，会经常使用。</p>
<ol>
<li>FPS：绿色的柱越高， FPS 值也越高，用户看着就越流畅，体验就越好。如果太小，用户看着会有卡顿的感觉</li>
<li>CPU：这个面积图(area chart)表明了哪种事件在消耗 CPU 资源。</li>
<li>NET：某一个时刻页面的表现形式（以某一个时刻的画面展示）！把鼠标移动到FPS，CPU或者NET区域任意的位置，就会展示这个时间节点面的截图。左右移动鼠标，可以重发当时的屏幕录像，利用这个可以用来分析各个动画的各个细节，或者是页面加载的快慢！</li>
<li>Flame Chart：蓝色(Loading)：网络请求和HTML解析 黄色(Scripting)：JavaScript编译和执行紫色(Rendering)：样式解析，计算，渲染。绿色(Painting)：重排，重绘 灰色(other)：其它资源花费加载的时间白色(Idle)：空闲等待时间</li>
</ol>
<h1 id="application"><a href="#application" class="headerlink" title="application"></a>application</h1><ol>
<li>cookie</li>
<li>localstorage和localsession</li>
<li>缓存</li>
<li>IndexedDB</li>
<li>Frames:将页面上的资源按frame类别进行组织显示。顶级的top是一个主文档，在top下面是主文档的Fonts、Images、Scripts、Stylesheets等资源。最后一个就是主文件自身。</li>
</ol>
<h1 id="插件集"><a href="#插件集" class="headerlink" title="插件集"></a>插件集</h1><ol>
<li>HostAdmin：管理host的一个工具</li>
<li>JSON Editor/JSON Viewer：json格式化的工具</li>
<li>QR码发生器：把当前页面的url转成二维码，使用场景就是当要使用手机测试的时候，懒得在手机上输入整个网址，直接扫码就可在手机访问。</li>
<li>vue-devtools：使用vue开发</li>
<li>WEB前端助手(FeHelper)</li>
<li>Performance-Analyser：网页性能分析工具</li>
<li>划词翻译</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;在前端的日常开发上，经常会使用到chrome浏览器的开发者工具，在下面对chrome开发者工具各个面板的功能做了简单的整理。&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对JS中事件委托的理解</title>
    <link href="http://yoursite.com/2018/03/30/%E5%AF%B9JS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/30/对JS中事件委托的理解/</id>
    <published>2018-03-30T02:44:36.000Z</published>
    <updated>2018-04-09T01:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><b>对JS的事件委托及事件冒泡、事件捕获的深入理解。</b><br><a id="more"></a></p>
<h1 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h1><p>利用事件冒泡处理<b>动态元素</b>事件绑定的方法，专业术语叫事件委托。<br>使用事件委托技术可以避免对特定的每个节点添加事件监听器，相反，事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。</p>
<h2 id="事件冒泡与事件捕获"><a href="#事件冒泡与事件捕获" class="headerlink" title="事件冒泡与事件捕获"></a>事件冒泡与事件捕获</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></div><div class="line">　　<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"> <span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">                alert(<span class="string">"parent事件被触发，"</span>+<span class="keyword">this</span>.id);</div><div class="line">            &#125;);</div><div class="line">            <span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">                alert(<span class="string">"child事件被触发，"</span>+<span class="keyword">this</span>.id)</div><div class="line">            &#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>结果：child事件被触发，child；parent事件被触发，parent<br>结论：先child，然后parent。事件的触发顺序自内向外，这就是事件冒泡。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"测试事件冒泡"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> 依次弹出”red“,"green","yellow"。</div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">var</span> $input = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"input"</span>)[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> $div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> $body = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"body"</span>)[<span class="number">0</span>];</div><div class="line"> </div><div class="line"> $div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line"> <span class="keyword">this</span>.style.border = <span class="string">"5px solid green"</span>;</div><div class="line"> alert(<span class="string">"green"</span>)</div><div class="line">&#125;;</div><div class="line">$body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line"> <span class="keyword">this</span>.style.border = <span class="string">"5px solid yellow"</span>;</div><div class="line"> alert(<span class="string">"yellow"</span>)</div><div class="line">&#125;;</div><div class="line">$input.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line"> <span class="keyword">this</span>.style.border = <span class="string">"5px solid red"</span>;</div><div class="line"> <span class="keyword">var</span> e = e || <span class="built_in">window</span>.e;</div><div class="line"> alert(<span class="string">"red"</span>);<span class="comment">// 只弹出red</span></div><div class="line"> e.stopPropagation();</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>阻止事件冒泡：stopPropagation()</p>
<ol>
<li>结果：parent事件被触发，parent；child事件被触发，child<br>结论：先parent,然后child。事件触发顺序变更为自外向内，这就是事件捕获。</li>
<li>阻止默认事件<br>有一些html元素默认的行为，比如说a标签，点击后有跳转动作；form表单中的submit类型的input有一个默认提交跳转事件；reset类型的input有重置表单行为。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>)[<span class="number">0</span>];</div><div class="line">$a.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line"> alert(<span class="string">"跳转动作被我阻止了"</span>);</div><div class="line"> e.preventDefault();</div><div class="line"> <span class="comment">//return false;//也可以</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>既然return false 和 e.preventDefault()都是一样的效果，那它们有区别吗？仅仅是在HTML事件属性 和 DOM0级事件处理方法中 才能通过返回 return false 的形式组织事件宿主的默认行为。</p>
<h1 id="事件委托的好处"><a href="#事件委托的好处" class="headerlink" title="事件委托的好处"></a>事件委托的好处</h1><ol>
<li>事件委托技术可以避免对每个子元素添加事件监听器，减少操作DOM节点的次数，从而减少浏览器的重绘和重排，提高代码的性能。</li>
<li>使用事件委托，只有父元素与DOM存在交互，其他的操作都是在JS虚拟内存中完成的，这样就大大提高了性能。</li>
</ol>
<h1 id="什么时候用事件委托"><a href="#什么时候用事件委托" class="headerlink" title="什么时候用事件委托"></a>什么时候用事件委托</h1><p>当子元素有很多，需要对子元素的事件进行监听的时候</p>
<h1 id="事件委托三部曲"><a href="#事件委托三部曲" class="headerlink" title="事件委托三部曲"></a>事件委托三部曲</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>测试4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>测试5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>测试6<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>测试7<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>测试8<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"ul"</span>)[<span class="number">0</span>].addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"点击的内容是："</span>+e.target.innerHTML);</div><div class="line">&#125;);<span class="comment">//js原生事件委托</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>给父元素绑定事件<br>给元素ul添加绑定事件，通过addEventListener为点击事件click添加绑定</li>
<li>监听子元素的冒泡事件<br>这里默认是冒泡，点击子元素li会向上冒泡</li>
<li>找到是哪个子元素的事件<br>通过匿名回调函数的参数e用来接收事件对象，通过target获取触发事件的目标</li>
</ol>
<h2 id="JQ实现事件委托"><a href="#JQ实现事件委托" class="headerlink" title="JQ实现事件委托"></a>JQ实现事件委托</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"ul"</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    alert(<span class="string">"点击的内容是："</span>+$(e.target).text());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ndContainer.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">       <span class="keyword">const</span> target = e.target;</div><div class="line">       <span class="keyword">if</span> (target.tagName === <span class="string">'LI'</span>) &#123;</div><div class="line">           alert(target.innerHTML);</div><div class="line">       &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;对JS的事件委托及事件冒泡、事件捕获的深入理解。&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>npm使用注意</title>
    <link href="http://yoursite.com/2018/03/22/npm%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/"/>
    <id>http://yoursite.com/2018/03/22/npm使用注意/</id>
    <published>2018-03-22T02:40:45.000Z</published>
    <updated>2018-04-09T01:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><b>npm使用过程中需要注意的地方及发现的新功能整理。</b><br><a id="more"></a></p>
<h1 id="npm的–save-dev与–save的区别"><a href="#npm的–save-dev与–save的区别" class="headerlink" title="npm的–save-dev与–save的区别"></a>npm的–save-dev与–save的区别</h1><p>npm install –save和npm install –-save-dev在安装npm包时，都能将它们的信息写在package.json里</p>
<ol>
<li>表面的区别<br>–save 会把依赖包名称添加到 package.json 文件 dependencies 键下；<br>–save-dev 则添加到 package.json 文件 devDependencies 键下。</li>
<li>真实的区别<br>dependencies是运行时依赖，devDependencies是开发时的依赖，即–save安装的是运行时需要的包，–-save-dev安装的是开发时需要的包。</li>
</ol>
<h1 id="mac上通过nvm来管理不同node版本"><a href="#mac上通过nvm来管理不同node版本" class="headerlink" title="mac上通过nvm来管理不同node版本"></a>mac上通过nvm来管理不同node版本</h1><p>NVM:node版本管理工具,nvm use指令只会在当前的shell生效，当你开了新的shell就会发现$PATH的值已经不包含刚才设定的node目录了。 </p>
<ol>
<li><p>安装nvm</p>
<blockquote>
<p>brew install nvm</p>
</blockquote>
</li>
<li><p>使nvm生效</p>
<blockquote>
<p>source $(brew –prefix nvm)/nvm.sh</p>
</blockquote>
</li>
</ol>
<p>或者：</p>
<blockquote>
<p>echo “source $(brew –prefix nvm)/nvm.sh” &gt;&gt; .bash_profile<br>. ~/.bash_profile</p>
</blockquote>
<ol>
<li>使用nvm安裝Node.js<br>查看可用版本：<blockquote>
<p>nvm ls-remote</p>
</blockquote>
</li>
</ol>
<p>安装：</p>
<blockquote>
<p>nvm install v5.7.0</p>
</blockquote>
<ol>
<li>使用nvm无痛切换Node.js版本<br>nvm会把各个版本的node安装在/usr/local/opt/nvm底下。可以看看该目录地下放了哪些东西：<blockquote>
<p> $ ls /usr/local/opt/nvm</p>
</blockquote>
</li>
</ol>
<p>查看当前可用版本:</p>
<blockquote>
<p>nvm ls</p>
</blockquote>
<p>切换版本：</p>
<blockquote>
<p>nvm use <version><br>nvm use –delete-prefix v5.7.0</version></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;npm使用过程中需要注意的地方及发现的新功能整理。&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Grid布局</title>
    <link href="http://yoursite.com/2018/03/07/Grid%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/03/07/Grid布局/</id>
    <published>2018-03-07T03:04:01.000Z</published>
    <updated>2018-03-07T06:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><b>CSS 网格布局(Grid Layout) 是CSS中最强大的布局系统。 这是一个二维系统，这意味着它可以同时处理列和行，不像 flexbox 那样主要是一维系统。 你可以通过将CSS规则应用于父元素（成为网格容器）和该元素的子元素（网格元素），来使用网格布局。</b><br><a id="more"></a></p>
<h1 id="父容器-Grid-Container-的属性"><a href="#父容器-Grid-Container-的属性" class="headerlink" title="父容器(Grid Container)的属性"></a>父容器(Grid Container)的属性</h1><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>将元素定义为 grid contaienr，并为其内容建立新的网格格式化上下文(grid formatting context)。<b>注意</b>：column, float, clear, 以及 vertical-align 对一个 grid container 没有影响</p>
<ol>
<li>grid - 生成一个块级(block-level)网格</li>
<li>inline-grid - 生成一个行级(inline-level)网格</li>
<li>subgrid - 如果你的 grid container 本身就是一个 grid item（即,嵌套网格），你可以使用这个属性来表示你想从它的父节点获取它的行/列的大小，而不是指定它自己的大小。</li>
</ol>
<h2 id="grid-template-columns-grid-template-rows"><a href="#grid-template-columns-grid-template-rows" class="headerlink" title="grid-template-columns / grid-template-rows"></a>grid-template-columns / grid-template-rows</h2><p>使用以空格分隔的多个值来定义网格的列和行。这些值表示轨道大小(track size)，它们之间的空格代表表格线(grid line)。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">  grid-template-columns: <span class="tag">&lt;<span class="name">track-size</span>&gt;</span> ... | <span class="tag">&lt;<span class="name">line-name</span>&gt;</span> <span class="tag">&lt;<span class="name">track-size</span>&gt;</span> ...;</div><div class="line">  grid-template-rows: <span class="tag">&lt;<span class="name">track-size</span>&gt;</span> ... | <span class="tag">&lt;<span class="name">line-name</span>&gt;</span> <span class="tag">&lt;<span class="name">track-size</span>&gt;</span> ...;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>轨道值之间仅仅有空格时，网格线会被自动分配数字名称:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">40px</span> <span class="number">50px</span> auto <span class="number">50px</span> <span class="number">40px</span>;</div><div class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">25%</span> <span class="number">100px</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义中包含重复的部分，则可以使用repeat() 符号来简化写法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 20px [col-start]) <span class="number">5%</span>;</div><div class="line">&#125;<span class="comment">/* 等价于 */</span></div><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start] <span class="number">5%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>“fr”单位允许您将轨道大小设置为网格容器自由空间的一部分。 例如，下面的代码会将每个 grid item 为 grid container 宽度的三分之一：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自由空间是在排除所有不可伸缩的 grid item 之后计算得到的。 在下面的示例中，fr单位可用的自由空间总量不包括50px:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">50px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h2><p>通过引用 grid-area属性指定的网格区域的名称来定义网格模板。 重复网格区域的名称导致内容扩展到这些单元格。 点号表示一个空单元格。 语法本身提供了网格结构的可视化。</p>
<ol>
<li><grid-area-name> - 使用 grid-area 属性设置的网格区域的名称</grid-area-name></li>
<li>. - 点号代表一个空网格单元</li>
<li>none - 没有定义网格区域<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.item-a</span> &#123;</div><div class="line">  <span class="attribute">grid-area</span>: header;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item-b</span> &#123;</div><div class="line">  <span class="attribute">grid-area</span>: main;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item-c</span> &#123;</div><div class="line">  <span class="attribute">grid-area</span>: sidebar;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item-d</span> &#123;</div><div class="line">  <span class="attribute">grid-area</span>: footer;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</div><div class="line">  <span class="attribute">grid-template-rows</span>: auto;</div><div class="line">  <span class="attribute">grid-template-areas</span>: </div><div class="line">    <span class="string">"header header header header"</span></div><div class="line">    <span class="string">"main main . sidebar"</span></div><div class="line">    <span class="string">"footer footer footer footer"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/2018/03/07/Grid布局/grid.png" alt="grid"></p>
<h2 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h2><p>在单个声明中定义 grid-template-rows、grid-template-columns、grid-template-areas 的简写。</p>
<ol>
<li>none - 将三个属性都设置为其初始值</li>
<li>subgrid - 把 grid-template-rows 和 grid-template-columns 设置为 subgrid, 并且 grid-template-areas 设置为初始值</li>
<li>grid-template-rows / &lt;grid-template-columns - 把 grid-template-columns 和 grid-template-rows 设置为指定值, 与此同时, 设置 grid-template-areas 为 none<h2 id="grid-column-gap-grid-row-gap"><a href="#grid-column-gap-grid-row-gap" class="headerlink" title="grid-column-gap / grid-row-gap"></a>grid-column-gap / grid-row-gap</h2>指定网格线的大小，你可以把它想象为设置列/行之间的间距的宽度。<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">50px</span> <span class="number">100px</span>;</div><div class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">80px</span> auto <span class="number">80px</span>; </div><div class="line">  <span class="attribute">grid-column-gap</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">grid-row-gap</span>: <span class="number">15px</span>;</div><div class="line">&#125;<span class="comment">/* 只能在列/行之间创建缝隙，而不是在外部边缘创建 */</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h2><p>grid-row-gap 和 grid-column-gap 的缩写<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">50px</span> <span class="number">100px</span>;</div><div class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">80px</span> auto <span class="number">80px</span>; </div><div class="line">   <span class="attribute">grid-gap</span>: <span class="number">10px</span> <span class="number">15px</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h2 id="justify-items"><a href="#justify-items" class="headerlink" title="justify-items"></a>justify-items</h2><p>沿着行轴对齐网格内的内容（与之对应的是 align-items, 即沿着列轴对齐），该值适用于容器内的所有的 grid items。</p>
<ol>
<li>start: 内容与网格区域的左端对齐</li>
<li>end: 内容与网格区域的右端对齐</li>
<li>center: 内容位于网格区域的中间位置</li>
<li>stretch: 内容宽度占据整个网格区域空间(这是默认值)</li>
</ol>
<h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>沿着列轴对齐grid item 里的内容（与之对应的是使用 justify-items 设置沿着行轴对齐），该值适用于容器内的所有 grid items。</p>
<ol>
<li>start: 内容与网格区域的顶端对齐</li>
<li>end: 内容与网格区域的底部对齐</li>
<li>center: 内容位于网格区域的垂直中心位置</li>
<li>stretch: 内容高度占据整个网格区域空间(这是默认值)<h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2>有时，网格的总大小可能小于其网格容器的大小。如果你的所有 grid items 都使用像px这样的非弹性单位来设置大小，则可能发生这种情况。此时，你可以设置网格容器内的网格的对齐方式。 此属性沿着行轴对齐网格（与之对应的是 align-content, 沿着列轴对齐）。</li>
<li>start - 网格与网格容器的左边对齐</li>
<li>end - 网格与网格容器的右边对齐</li>
<li>center - 网格与网格容器的中间对齐</li>
<li>stretch - 调整g rid item 的大小，让宽度填充整个网格容器</li>
<li>space-around - 在 grid item 之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半</li>
<li>space-between - 在 grid item 之间设置均等宽度空白间隙，其外边缘无间隙</li>
<li>space-evenly - 在每个 grid item 之间设置均等宽度的空白间隙，包括外边缘<h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2>有时，网格的总大小可能小于其网格容器的大小。如果你的所有 grid items 都使用像px这样的非弹性单位来设置大小，则可能发生这种情况。此时，你可以设置网格容器内的网格的对齐方式。 此属性沿着列轴对齐网格（与之对应的是 justify-content, 即沿着行轴对齐）。</li>
<li>start - 网格与网格容器的顶部对齐</li>
<li>end - 网格与网格容器的底部对齐</li>
<li>center - 网格与网格容器的中间对齐</li>
<li>stretch - 调整 grid item 的大小，让高度填充整个网格容器</li>
<li>space-around - 在 grid item 之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半</li>
<li>space-between - 在 grid item 之间设置均等宽度空白间隙，其外边缘无间隙</li>
<li>space-evenly - 在每个 grid item 之间设置均等宽度的空白间隙，包括外边缘<h2 id="grid-auto-columns-grid-auto-rows"><a href="#grid-auto-columns-grid-auto-rows" class="headerlink" title="grid-auto-columns / grid-auto-rows"></a>grid-auto-columns / grid-auto-rows</h2>指定自动生成的网格轨道（又名隐式网格轨道）的大小。 隐式网格轨道在你显式的定位超出指定网格范围的行或列（使用 grid-template-rows/grid-template-columns）时被创建。<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">grid-auto-columns</span>: <span class="number">60px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h2><p>如果你存在没有显示指明放置在网格上的 grid item，则自动放置算法会自动放置这些项目。 而该属性则用于控制自动布局算法的工作方式。</p>
<ol>
<li>row - 告诉自动布局算法依次填充每行，根据需要添加新行</li>
<li>column - 告诉自动布局算法依次填充每列，根据需要添加新列</li>
<li>dense - 告诉自动布局算法，如果后面出现较小的 grid item，则尝试在网格中填充空洞</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000012889793" target="_blank" rel="external">更多参看可以查看</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;CSS 网格布局(Grid Layout) 是CSS中最强大的布局系统。 这是一个二维系统，这意味着它可以同时处理列和行，不像 flexbox 那样主要是一维系统。 你可以通过将CSS规则应用于父元素（成为网格容器）和该元素的子元素（网格元素），来使用网格布局。&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack4.X 配置记录</title>
    <link href="http://yoursite.com/2018/03/05/webpack-%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/03/05/webpack-配置记录/</id>
    <published>2018-03-05T02:52:59.000Z</published>
    <updated>2018-04-09T01:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><b>在使用webpack的过程中，对webpack常用配置的整理，以巩固webpack的知识。</b><br><a id="more"></a></p>
<h1 id="使用html-webpack-plugin处理缓存问题"><a href="#使用html-webpack-plugin处理缓存问题" class="headerlink" title="使用html-webpack-plugin处理缓存问题"></a>使用html-webpack-plugin处理缓存问题</h1><p>网站上线后，用户第一次访问首页，下载了home.js，第二次访问又下载了home.js，这肯定是不行的，所以我们一般都会做一个缓存，用户下载一次home.js后，第二次就不下载了。每次代码更新后，让打包生成的名字不一样，就可以实现代码更新。</p>
<blockquote>
<p>npm install html-webpack-plugin –save-dev</p>
</blockquote>
<p>修改webpack.dev.config.js，增加plugin:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line"></div><div class="line">    plugins: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">        <span class="attr">filename</span>: <span class="string">'index.html'</span>,</div><div class="line">        <span class="attr">template</span>: path.join(__dirname, <span class="string">'src/index.html'</span>)</div><div class="line">    &#125;)]</div></pre></td></tr></table></figure></p>
<p><b>错误：compilation.mainTemplate.applyPluginsWaterfall is not a function:</b><br>使用webpack官方维护的html-webpack-plugin来代替第三方的：</p>
<blockquote>
<p>yarn add webpack-contrib/html-webpack-plugin -D</p>
</blockquote>
<h1 id="devtool优化"><a href="#devtool优化" class="headerlink" title="devtool优化"></a>devtool优化</h1><p>webpack.dev.config.js添加：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">devtool: <span class="string">'cheap-module-eval-source-map'</span></div></pre></td></tr></table></figure></p>
<p>具体配置参考：<a href="https://segmentfault.com/a/1190000004280859" target="_blank" rel="external">https://segmentfault.com/a/1190000004280859</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;在使用webpack的过程中，对webpack常用配置的整理，以巩固webpack的知识。&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端面试题集锦二</title>
    <link href="http://yoursite.com/2018/03/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/03/02/前端面试题集锦二/</id>
    <published>2018-03-02T06:53:55.000Z</published>
    <updated>2018-04-09T01:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><b>前端面试题整理二</b><br><a id="more"></a></p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="同源与跨域"><a href="#同源与跨域" class="headerlink" title="同源与跨域"></a>同源与跨域</h2><h3 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h3><p>协议相同、域名相同、端口相同（用于保护用户数据的安全，防止恶意访问）</p>
<h2 id="如果非同源，共有三种行为受到限制"><a href="#如果非同源，共有三种行为受到限制" class="headerlink" title="如果非同源，共有三种行为受到限制"></a>如果非同源，共有三种行为受到限制</h2><p>Cookie、LocalStorage 和 IndexDB无法读取；Dom无法获取；Ajax请求。</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ol>
<li>读取cookie<br><b>window.domain设置同一父域名</b><br>对于同一个页面，不同的iframe之间是可以共享window对象，只不过不能使用另一个页面window的对象的属性和方法（极少部分除外，如h5中的postMessage方法）。此时，可以使用domain将iframe设置为相同的域。<br>如有一个网页A<a href="http://w1.example.a.com，一个网页Bhttp://w2,example.b.com。只要设置相同的document.domain，两个页面就能共享数据和DOM（LocalStorage" target="_blank" rel="external">http://w1.example.a.com，一个网页Bhttp://w2,example.b.com。只要设置相同的document.domain，两个页面就能共享数据和DOM（LocalStorage</a> 和 IndexDB 无法通过这种方法传递）：<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.domain = "example.com" //必须为自身 或父域</div></pre></td></tr></table></figure>
</li>
</ol>
<p>比如你在网页A设置一个cookie<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//网页A</div><div class="line">document.cookie ="i'm A"</div></pre></td></tr></table></figure></p>
<p>就可以在网页B访问到这个属性<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//网页B</div><div class="line">document.cookie // i'm A</div></pre></td></tr></table></figure></p>
<ol>
<li>DOM的获取<br>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。<br><b>对于完全不同源的网站,可以采用下面三种方法:</b>window.name、跨文档通信API、片段识别符<br>2.1 window.name<br>window.name这个浏览器窗口属性最大的特点就是，只要在同一个窗口中，无论是否同源，所有页面都能共享这个属性。每个页面对window.name都有读写的权限。而且window.name可以存储容量比较大，一般有2M（不同浏览器容量不容）<br>2.2 跨文档通信API<br>H5为了解决跨源的问题，引入了一个全新的API,为window新增了一个方法window.postMessage，允许跨窗口通信，无论是否同源。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 比如在窗口'http://aaa.com'中，想要向另一个页面'http://bbb.com'发送消息。调用postMessage方法即可</div><div class="line">//aaa.com中写入</div><div class="line">var popup = window.open('http://bbb.com', 'title');</div><div class="line">popup.postMessage('Hello World!', 'http://bbb.com');</div><div class="line">// bbb中通过message事件监听消息</div><div class="line">window.addEventListener('message', function(e) &#123;</div><div class="line">  console.log(e.data);</div><div class="line">&#125;,false);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>其中message事件对象event提供三个属性:event.source：消息来源的地址;event.origin：消息发向的地址;event.data：消息内容<br>2.3 片段识别符<br>片段识别符指的是，URL的#号后面的部分。如果仅是识别符改变，不会导致页面刷新。父页面可以将信息写入子页面的识别符中<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var src = originURL + '#' + data;</div><div class="line">document.getElementById('myIFrame').src = src;</div></pre></td></tr></table></figure></p>
<p>子页面通过onhashchange监听:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">window.onhashchange = checkMessage;</div><div class="line"></div><div class="line">function checkMessage() &#123;</div><div class="line">  var message = window.location.hash;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子页面也可以把信息写入父页面的识别符<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parent.location.href= target + "#" + hash;</div></pre></td></tr></table></figure></p>
<ol>
<li>AJAX请求的跨域<br>3.1 JSONP 只支持get请求，不支持post请求；兼容性较好<br>jsonp是利用script标签可以跨域访问资源的特性，在页面内动态插入一个script标签，向服务器发起数据的跨域请求。服务器收到请求后，将数据放在一个指定名字的回调函数中传回</li>
</ol>
<p>3.2 CORS 支持所有请求；不兼容老旧浏览器<br>cors请求的局限就小很多了，它是一个W3C标准，允许向跨源服务器，发起XMLHttpRequest请求。支持IE10及其以上,整个CORS通信过程，都是浏览器自动完成，不需要用户参与。实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="for循环setTimeout500ms打印出1-10"><a href="#for循环setTimeout500ms打印出1-10" class="headerlink" title="for循环setTimeout500ms打印出1-10"></a>for循环setTimeout500ms打印出1-10</h2><p>闭包+JS加载顺序+setTimeout异步函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt; <span class="number">11</span>;i++)&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> j = i;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(j);</div><div class="line">        &#125;,<span class="number">500</span>)</div><div class="line">    &#125;;</div><div class="line">    a();</div><div class="line">&#125;<span class="comment">// 若不用闭包，在执行setTimeout之前，i已经变成11，即会打印出十个11；</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; <span class="number">11</span>;i++)&#123;</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(i);</div><div class="line">        &#125;,<span class="number">500</span>)</div><div class="line">&#125;<span class="comment">// let</span></div></pre></td></tr></table></figure>
<p>变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i;let声明的变量仅在块级作用域内有效,当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量.</p>
<h2 id="alert-1-amp-amp-2-alert-1-0"><a href="#alert-1-amp-amp-2-alert-1-0" class="headerlink" title="alert(1&amp;&amp;2),alert(1||0)"></a>alert(1&amp;&amp;2),alert(1||0)</h2><p>结果为：2，1.<br>true:1;false:0。</p>
<ol>
<li>只要“&amp;&amp;”前面是false，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”前面的值;</li>
<li>只要“&amp;&amp;”前面是true，无论“&amp;&amp;”后面是true还是false，结果都将返“&amp;&amp;”后面的值;</li>
<li>只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。</li>
<li>只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。</li>
</ol>
<h2 id="mouseenter和mouseover的区别"><a href="#mouseenter和mouseover的区别" class="headerlink" title="mouseenter和mouseover的区别"></a>mouseenter和mouseover的区别</h2><ol>
<li>只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件。对应mouseleave</li>
<li>不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件。对应mouseout</li>
</ol>
<h2 id="用正则表达式匹配字符串，以字母开头，后面是数字、字符串或者下划线，长度为9-20"><a href="#用正则表达式匹配字符串，以字母开头，后面是数字、字符串或者下划线，长度为9-20" class="headerlink" title="用正则表达式匹配字符串，以字母开头，后面是数字、字符串或者下划线，长度为9-20"></a>用正则表达式匹配字符串，以字母开头，后面是数字、字符串或者下划线，长度为9-20</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> re=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^[a-zA-Z][a-zA-Z0-9_]&#123;9,20&#125;$"</span>);</div></pre></td></tr></table></figure>
<h2 id="js字符串两边截取空白的trim的原型方法的实现"><a href="#js字符串两边截取空白的trim的原型方法的实现" class="headerlink" title="js字符串两边截取空白的trim的原型方法的实现"></a>js字符串两边截取空白的trim的原型方法的实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/(^\s*)|(\s*$)/g</span>,<span class="string">''</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 删除左边的空格</div><div class="line">*/</div><div class="line"><span class="built_in">String</span>.prototype.trim=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/(^\s*)/g</span>,<span class="string">''</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 删除右边的空格</div><div class="line">*/</div><div class="line"><span class="built_in">String</span>.prototype.trim=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/(\s*$)/g</span>,<span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="经典判断输出题"><a href="#经典判断输出题" class="headerlink" title="经典判断输出题"></a>经典判断输出题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">4</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    a=<span class="number">3</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line">b();<span class="comment">// 3,因为里面修改了a这个全局变量，那个function a()&#123;&#125;是用来干扰的，虽然函数声明会提升，就被a给覆盖掉了</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> baz = <span class="number">3</span>;</div><div class="line"><span class="keyword">var</span> bazz = &#123;</div><div class="line">    <span class="attr">baz</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">getbaz</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.baz</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(bazz.getbaz());<span class="comment">// 2</span></div><div class="line"><span class="keyword">var</span> g = bazz.getbaz;</div><div class="line"><span class="built_in">console</span>.log(g());<span class="comment">// 3</span></div><div class="line"><span class="comment">// this的指向,函数作为对象本身属性调用的时候this指向对象，作为普通函数调用的时候就指向全局</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(i)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">arr[<span class="number">3</span>]();<span class="comment">// 5,闭包,alert(i)的i为全局变量i</span></div></pre></td></tr></table></figure>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="css选择器-和"><a href="#css选择器-和" class="headerlink" title="css选择器+和 ~"></a>css选择器+和 ~</h2><h2 id="写出position不同值和区别"><a href="#写出position不同值和区别" class="headerlink" title="写出position不同值和区别"></a>写出position不同值和区别</h2><ol>
<li>absolute: 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。(不占位)</li>
<li>relative: 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。（占位）</li>
<li>static:   默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）inherit：规定应该从父元素继承 position 属性的值。</li>
<li>fixed:    生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li>
<li>inherit:     规定应该从父元素继承 position 属性的值。  </li>
</ol>
<h2 id="写一个div-css布局，左边图片右边文字，文字环绕图片，外面容器固定宽度，文字不固定"><a href="#写一个div-css布局，左边图片右边文字，文字环绕图片，外面容器固定宽度，文字不固定" class="headerlink" title="写一个div+css布局，左边图片右边文字，文字环绕图片，外面容器固定宽度，文字不固定"></a>写一个div+css布局，左边图片右边文字，文字环绕图片，外面容器固定宽度，文字不固定</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 500px;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/logo.png"</span> <span class="attr">style</span>=<span class="string">"float: left;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>esProc represents a broad category of OLAP tools especially for complicated structured data processing. It restores the true meaning of OLAP, which is reflected in the following aspects: First, it does not require pre-data-modeling for your analysis goal, breaking the limitations of traditional OLAP and allows users to freely conduct bound-free data analysis. Besides, esProc can conveniently reference <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="reflow和repaint的理解"><a href="#reflow和repaint的理解" class="headerlink" title="reflow和repaint的理解"></a>reflow和repaint的理解</h2><p>repaint就是重绘，reflow就是回流。repaint主要是针对某一个DOM元素进行的重绘，reflow则是回流，针对整个页面的重排,在性能优先的前提下，性能消耗 reflow大于repaint。如果渲染树的结点发生了结构性变化，例如宽度、高度或者位置上的变化时，那么会触发Reflow(回流)的逻辑。我们第一次进入一个页面时便会至少触发一次这个逻辑。如果渲染树结点发生了非结构性变化，例如背景色等的变化时，那么会触发Repaint(重绘)的逻辑。<br><b>常见触发场景：</b></p>
<ol>
<li>触发repaint：<br>1.1  color的修改，如color=#ddd；<br>1.2  text-align的修改，如text-align=center；<br>1.3  a:hover也会造成重绘。<br>1.4  :hover引起的颜色等不导致页面回流的style变动。</li>
<li>触发reflow：<br>2.1  width/height/border/margin/padding的修改，如width=778px；<br>2.2  动画，:hover等伪类引起的元素表现改动，display=none等造成页面回流；<br>2.3  appendChild等DOM元素操作；<br>2.4  font类style的修改；<br>2.5  background的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分background的修改只触发repaint，当然IE不用考虑；<br>2.6  scroll页面，这个不可避免；<br>2.7  resize页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize程序窗口大小的多窗口操作系统。<br>2.8  读取元素的属性（这个无法理解，但是技术达人是这么说的，那就把它当做定理吧）：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))；<br><b>避免和最小化影响:</b></li>
<li>尽可能在DOM末梢通过改变class来修改元素的style属性：尽可能的减少受影响的DOM元素。</li>
<li>避免设置多项内联样式：使用常用的class的方式进行设置样式，以避免设置样式时访问DOM的低效率。</li>
<li>设置动画元素position属性为fixed或者absolute：由于当前元素从DOM流中独立出来，因此受影响的只有当前元素，元素repaint。</li>
<li>牺牲平滑度满足性能：动画精度太强，会造成更多次的repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。</li>
<li>避免使用table进行布局：table的每个元素的大小以及内容的改动，都会导致整个table进行重新计算，造成大幅度的repaint或者reflow。改用div则可以进行针对性的repaint和避免不必要的reflow。</li>
<li>避免在CSS中使用运算式：学习CSS的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;前端面试题整理二&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初涉react-重点记录</title>
    <link href="http://yoursite.com/2018/02/26/%E5%88%9D%E6%B6%89react-%E9%87%8D%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/02/26/初涉react-重点记录/</id>
    <published>2018-02-26T06:22:11.000Z</published>
    <updated>2018-04-09T01:53:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><b>初次学习React的过程中的重点记录。</b><br><a id="more"></a></p>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="Props和State的区别"><a href="#Props和State的区别" class="headerlink" title="Props和State的区别"></a>Props和State的区别</h2><p><b>props:</b><br>props是一个组件的设置参数，可以在父控件中选择性设置。父组件对子控件的props进行赋值，并且props的值不可改变。一个子控件自身不能改变自己的 props。<br><b>state:</b><br>当一个组件 mounts的时候，state如果设置有默认值的会被使用，并且state可能时刻的被改变。一个子控件自身可以管理自己的state，但是需要注意的是，无法管理其子控件的state。所以可以认为，state是子控件自身私有的。<br><b>总结:</b><br>props是一个父组件传递给子组件的数据流，可以一直的被传递到子孙组件中。然而 state代表的是子组件自身的内部状态。从语义上讲，改变组件的状态，可能会导致dom结构的改变或者重新渲染。而props是父组件传递的参数，所以可以被用于初始化渲染和改变组件自身的状态，虽然大多数时候组件的状态是又外部事件触发改变的。我们需要知道的是，无论是state改变，还是父组件传递的 props改变，render方法都可能会被执行。</p>
<h2 id="JSX中的Children"><a href="#JSX中的Children" class="headerlink" title="JSX中的Children"></a>JSX中的Children</h2><p>JSX 表达式中可以包含开放标签和闭合标签，标签中的内容会被传递一个特殊的 props(属性) ：props.children，<b>传递children的方式：</b></p>
<ol>
<li><p>字符串字面量<br>在开放标签和闭合标签中放入一个字符串，那么 props.children 就是那个字符串.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span>// MyComponent 组件中的 props.children 值为字符串 "Hello world!"</div></pre></td></tr></table></figure>
</li>
<li><p>JSX Children<br>可以提供多个 JSX 元素作为 children:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">MyContainer</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">MyFirstComponent</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">MySecondComponent</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">MyContainer</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p><b>React组件不能返回多个React元素，但是单个JSX表达式可以有多个子元素，因此如果你想要渲染多个元素，你可以像上面一样，将其包裹在 div 中。</b><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  Here is a list:</div><div class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<ol>
<li><p>JavaScript 表达式作为 Children(子元素)<br>通过使用 {} 包裹，你可以将任何的 JavaScript 元素而作为 children(子元素) 传递：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span>&#123;'foo'&#125;<span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span>// 等价</div><div class="line"></div><div class="line">function Item(props) &#123;</div><div class="line">  return <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function TodoList() &#123;</div><div class="line">  const todos = ['finish doc', 'submit pr', 'nag dan to review'];</div><div class="line">  return (</div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">      &#123;todos.map((message) =&gt; <span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;message&#125;</span> <span class="attr">message</span>=<span class="string">&#123;message&#125;</span> /&gt;</span>)&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Functions(函数)作为Children(子元素)<br>如果有自定义组件，其 props.children 的值可以是回调函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Repeat(props) &#123;</div><div class="line">  let items = [];</div><div class="line">  for (let i = 0; i &lt; props.numTimes; i++) &#123;</div><div class="line">    items.push(props.children(i));</div><div class="line">  &#125;</div><div class="line">  return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function ListOfTenThings() &#123;</div><div class="line">  return (</div><div class="line">    &lt;Repeat numTimes=&#123;10&#125;&gt;</div><div class="line">      &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125;</div><div class="line">    &lt;/Repeat&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Booleans, Null, 和 Undefined 被忽略<br>false，null，undefined，和 true 都是有效的的 children(子元素) 。但是并不会被渲染</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;false&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;null&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;undefined&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;true&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果在输出中想要渲染 false ，true，null 或者 undefined ，你必须先将其转化为字符串:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  My JavaScript variable is &#123;String(myVariable)&#125;.</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在有条件性渲染 React 元素时非常有用。如果 showHeader 为 true 时，<header>会被渲染：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  &#123;showHeader &amp;&amp; <span class="tag">&lt;<span class="name">Header</span> /&gt;</span>&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">Content</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></header></p>
<h2 id="React实现按需加载"><a href="#React实现按需加载" class="headerlink" title="React实现按需加载"></a>React实现按需加载</h2><p>首屏加载的时候，就会很慢。因为他也下载了别的页面的js了，如果每个页面都打包了自己单独的JS，在进入自己页面的时候才加载对应的js，那首屏加载就会快很多。</p>
<blockquote>
<p>npm install bundle-loader –save-dev</p>
</blockquote>
<p>新建bundle.js:</p>
<blockquote>
<p>cd src/router<br>touch Bundle.js</p>
</blockquote>
<p>Bundle.js:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bundle</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    state = &#123;</div><div class="line">        <span class="comment">// short for "module" but that's a keyword in js, so "mod"</span></div><div class="line">        mod: <span class="literal">null</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    componentWillMount() &#123;</div><div class="line">        <span class="keyword">this</span>.load(<span class="keyword">this</span>.props)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentWillReceiveProps(nextProps) &#123;</div><div class="line">        <span class="keyword">if</span> (nextProps.load !== <span class="keyword">this</span>.props.load) &#123;</div><div class="line">            <span class="keyword">this</span>.load(nextProps)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    load(props) &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            <span class="attr">mod</span>: <span class="literal">null</span></div><div class="line">        &#125;);</div><div class="line">        props.load(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">this</span>.setState(&#123;</div><div class="line">                <span class="comment">// handle both es imports and cjs</span></div><div class="line">                mod: mod.default ? mod.default : mod</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.mod)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Bundle;</div></pre></td></tr></table></figure></p>
<p>改造路由器：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router, Route, Switch, Link&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> Bundle <span class="keyword">from</span> <span class="string">'./Bundle'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'bundle-loader?lazy&amp;name=home!pages/Home/Home'</span>;</div><div class="line"><span class="keyword">import</span> Page1 <span class="keyword">from</span> <span class="string">'bundle-loader?lazy&amp;name=page1!pages/Page1/Page1'</span>;</div><div class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'bundle-loader?lazy&amp;name=counter!pages/Counter/Counter'</span>;</div><div class="line"><span class="keyword">import</span> UserInfo <span class="keyword">from</span> <span class="string">'bundle-loader?lazy&amp;name=userInfo!pages/UserInfo/UserInfo'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Loading = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> createComponent = <span class="function">(<span class="params">component</span>) =&gt;</span> (props) =&gt; (</div><div class="line">    &lt;Bundle load=&#123;component&#125;&gt;</div><div class="line">        &#123;</div><div class="line">            (Component) =&gt; Component ? &lt;Component &#123;...props&#125; /&gt; : &lt;Loading/&gt;</div><div class="line">        &#125;</div><div class="line">    &lt;/Bundle&gt;</div><div class="line">);</div><div class="line"></div><div class="line">const getRouter = () =&gt; (</div><div class="line">    &lt;Router&gt;</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;ul&gt;</div><div class="line">                &lt;li&gt;&lt;Link to="/"&gt;首页&lt;/Link&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;Link to="/page1"&gt;Page1&lt;/Link&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;Link to="/counter"&gt;Counter&lt;/Link&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;Link to="/userinfo"&gt;UserInfo&lt;/Link&gt;&lt;/li&gt;</div><div class="line">            &lt;/ul&gt;</div><div class="line">            &lt;Switch&gt;</div><div class="line">                &lt;Route exact path="/" component=&#123;createComponent(Home)&#125;/&gt;</div><div class="line">                &lt;Route path="/page1" component=&#123;createComponent(Page1)&#125;/&gt;</div><div class="line">                &lt;Route path="/counter" component=&#123;createComponent(Counter)&#125;/&gt;</div><div class="line">                &lt;Route path="/userinfo" component=&#123;createComponent(UserInfo)&#125;/&gt;</div><div class="line">            &lt;/Switch&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/Router&gt;</div><div class="line">);</div><div class="line"></div><div class="line">export default getRouter;</div></pre></td></tr></table></figure></p>
<p>webpack.dev.config.js:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">        <span class="attr">path</span>: path.join(__dirname, <span class="string">'./dist'</span>),</div><div class="line">        <span class="attr">filename</span>: <span class="string">'bundle.js'</span>,</div><div class="line">        <span class="attr">chunkFilename</span>: <span class="string">'[name].js'</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="React-DevTools"><a href="#React-DevTools" class="headerlink" title="React DevTools"></a>React DevTools</h2><ol>
<li>在开发者工具的控制台中，选择 React 选项卡中的 Highlight Updates (高亮显示更新) 选项：<br>所有重新渲染的组件周围都会出现高亮显示的边框,可以让你知道没有必要重新渲染的组件.   </li>
</ol>
<h2 id="Context（上下文）"><a href="#Context（上下文）" class="headerlink" title="Context（上下文）"></a>Context（上下文）</h2><p>在 React 中，通过你的 React 组件很容易追踪数据流。但你察看一个组件时，你可以找出哪些属性(props)被传递，这使得你的应用非常容易理解。<br>在某些场景下，你想在整个组件树中传递数据，但却不想手动地在每一层传递属性。你可以直接在 React 中使用强大的”context” API解决上述问题。<br><b>注意：</b>希望使用应用程序更加稳定，就不要使用上下文(context)。这只是一个实验性的 API ，并且可能在未来的 React 版本中移除。</p>
<h2 id="片段-fragments"><a href="#片段-fragments" class="headerlink" title="片段(fragments)"></a>片段(fragments)</h2><p>片段(fragments) 可以让你将子元素列表添加到一个分组中，并且<b>不会在DOM中增加额外节点</b>。<br><figure class="highlight"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">  return (</div><div class="line">    &lt;React.Fragment&gt;</div><div class="line">      &lt;ChildA /&gt;</div><div class="line">      &lt;ChildB /&gt;</div><div class="line">      &lt;ChildC /&gt;</div><div class="line">    &lt;/React.Fragment&gt;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简写：<br><figure class="highlight"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Columns extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;&gt;</div><div class="line">        &lt;td&gt;Hello&lt;/td&gt;</div><div class="line">        &lt;td&gt;World&lt;/td&gt;</div><div class="line">      &lt;/&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="插槽-Portals"><a href="#插槽-Portals" class="headerlink" title="插槽(Portals)"></a>插槽(Portals)</h2><p>将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。<br><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReactDOM.createPortal(child, container) <span class="comment">// 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。</span></div></pre></td></tr></table></figure></p>
<figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">  <span class="comment">// React *不* 会创建一个新的 div。 它把 children 渲染到 `domNode` 中。</span></div><div class="line">  <span class="comment">// `domNode` 可以是任何有效的 DOM 节点，不管它在 DOM 中的位置。</span></div><div class="line">  <span class="keyword">return</span> ReactDOM.createPortal(</div><div class="line">    <span class="keyword">this</span>.props.children,</div><div class="line">    domNode,</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards以及提示框：</p>
<h2 id="错误边界-Error-Boundaries"><a href="#错误边界-Error-Boundaries" class="headerlink" title="错误边界(Error Boundaries)"></a>错误边界(Error Boundaries)</h2><p>错误边界是 React 组件，它可以在子组件树的任何位置捕获 JavaScript 错误，记录这些错误，并显示一个备用 UI ** ，而不是使整个组件树崩溃。 错误边界(Error Boundaries) 在渲染，生命周期方法以及整个组件树下的构造函数中捕获错误。<br><b>错误边界无法捕获如下错误:</b>事件处理、异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）、服务端渲染、错误边界自身抛出来的错误 （而不是其子组件）。<br><figure class="highlight"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class ErrorBoundary extends React.Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);</div><div class="line">    this.state = &#123; hasError: false &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidCatch(error, info) &#123;</div><div class="line">    // Display fallback UI</div><div class="line">    this.setState(&#123; hasError: true &#125;);</div><div class="line">    // You can also log the error to an error reporting service</div><div class="line">    logErrorToMyService(error, info);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    if (this.state.hasError) &#123;</div><div class="line">      // You can render any custom fallback UI</div><div class="line">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</div><div class="line">    &#125;</div><div class="line">    return this.props.children;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 像一个普通的组件一样使用：</div><div class="line">&lt;ErrorBoundary&gt;</div><div class="line">  &lt;MyWidget /&gt;</div><div class="line">&lt;/ErrorBoundary&gt;</div></pre></td></tr></table></figure></p>
<h2 id="高阶组件-Higher-Order-Components"><a href="#高阶组件-Higher-Order-Components" class="headerlink" title="高阶组件(Higher-Order Components)"></a>高阶组件(Higher-Order Components)</h2><p>高阶组件是一个函数，能够接受一个组件并返回一个新的组件。组件是将props转化成UI，然而高阶组件将一个组价转化成另外一个组件。<br><b>注意：</b>不要在render函数中使用高阶组件、静态方法必须复制、Refs不会被传递</p>
<h1 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h1><h2 id=""><a href="#" class="headerlink" title=""></a><redirect></redirect></h2><p>点击 /inbox/messages/5 这个链接，他们会被自动跳转到 /messages/5:<br><figure class="highlight typescript"><figcaption><span>jsx</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Redirect <span class="keyword">from</span>=<span class="string">"messages/:id"</span> to=<span class="string">"/messages/:id"</span> /&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;初次学习React的过程中的重点记录。&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的 Javascript 错误</title>
    <link href="http://yoursite.com/2018/02/07/%E5%B8%B8%E8%A7%81%E7%9A%84-Javascript-%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/02/07/常见的-Javascript-错误/</id>
    <published>2018-02-07T09:08:55.000Z</published>
    <updated>2018-02-08T01:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><b>10 种最常见的Javascript错误及阐述如何避免</b><br><a id="more"></a></p>
<h1 id="Uncaught-TypeError-Cannot-read-property-未捕获的错误类型：不能读取属性"><a href="#Uncaught-TypeError-Cannot-read-property-未捕获的错误类型：不能读取属性" class="headerlink" title="Uncaught TypeError: Cannot read property(未捕获的错误类型：不能读取属性)"></a>Uncaught TypeError: Cannot read property(未捕获的错误类型：不能读取属性)</h1><p>读取一个未定义的对象的属性或调用其方法时会发生的错误。<br>发生这种情况的原因很多，但常见的一种是在渲染 UI 组件时对于状态的初始化操作不当。</p>
<h1 id="TypeError-‘undefined’-is-not-an-object-错误类型：undefined不是一个对象"><a href="#TypeError-‘undefined’-is-not-an-object-错误类型：undefined不是一个对象" class="headerlink" title="TypeError: ‘undefined’ is not an object(错误类型：undefined不是一个对象)"></a>TypeError: ‘undefined’ is not an object(错误类型：undefined不是一个对象)</h1><p>读取属性或调用未定义对象上的方法时发生的错误</p>
<h1 id="TypeError-null-is-not-an-object-错误类型：null不是一个对象"><a href="#TypeError-null-is-not-an-object-错误类型：null不是一个对象" class="headerlink" title="TypeError: null is not an object(错误类型：null不是一个对象)"></a>TypeError: null is not an object(错误类型：null不是一个对象)</h1><p>读取属性或调用空对象上的方法时发生的错误<br>这种错误可能发生的一种场景是：如果在加载元素之前尝试在 JavaScript 中使用元素。 因为 DOM API 对于空白的对象引用返回值为 null。任何执行和处理 DOM 元素的 JS 代码都应该在创建 DOM 元素之后执行。 JS 代码按照 HTML 中的规定从上到下进行解释。 所以，如果 DOM 元素之前有一个标签，脚本标签内的 JS 代码将在浏览器解析 HTML 页面时执行。 如果在加载脚本之前尚未创建 DOM 元素，则会出现此错误。<br>在 JavaScript 中，null 和 undefined 是不一样的，这就是为什么我们看到两个不同的错误信息。undefined 通常是一个尚未分配的变量，而 null 表示该值为空。 要验证它们不相等，请尝试使用严格的相等运算符 ===</p>
<h1 id="unknown-Script-error"><a href="#unknown-Script-error" class="headerlink" title="(unknown): Script error"></a>(unknown): Script error</h1><p>当未捕获的 JavaScript 错误（通过window.onerror处理程序引发的错误，而不是捕获在try-catch中）被浏览器的跨域策略限制时，会产生这类的脚本错误。<br>任何未被捕获的错误将被报告为“脚本错误” 而不是包含有用的堆栈信息。这是一种浏览器安全措施，旨在防止跨域传递数据，否则将不允许进行通信。要获得真正的错误消息，请执行以下操作：</p>
<ol>
<li>发送 ‘Access-Control-Allow-Origin’ 头部<br>将 Access-Control-Allow-Origin 标头设置为 * 表示可以从任何域正确访问资源。</li>
<li>在 <script> 中设置 crossorigin=”anonymous” </li>
</ol>
</script></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;b&gt;10 种最常见的Javascript错误及阐述如何避免&lt;/b&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue埋坑合集</title>
    <link href="http://yoursite.com/2018/01/31/vue%E5%9F%8B%E5%9D%91%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2018/01/31/vue埋坑合集/</id>
    <published>2018-01-31T10:01:40.000Z</published>
    <updated>2018-02-24T02:24:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>总结了在Vue项目完成过程中的一些陷阱。</strong><br><a id="more"></a></p>
<h1 id="axios-get-url-params-传参"><a href="#axios-get-url-params-传参" class="headerlink" title="axios.get(url, params)传参"></a>axios.get(url, params)传参</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> params = &#123;</div><div class="line">    <span class="attr">params</span>: &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">''</span>,</div><div class="line">        <span class="attr">password</span>: <span class="string">''</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="vuex使用场景"><a href="#vuex使用场景" class="headerlink" title="vuex使用场景"></a>vuex使用场景</h1><p>vuex适合在大型前端应用中由于多处组件公用数据源的场景（多层嵌套组件通信、多个不关联的组件之间都需要使用某个属性）：<br>1、登录用户信息；<br>2、角色权限的路由；<br>…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;总结了在Vue项目完成过程中的一些陷阱。&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端面试题集锦</title>
    <link href="http://yoursite.com/2018/01/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6/"/>
    <id>http://yoursite.com/2018/01/26/前端面试题集锦/</id>
    <published>2018-01-26T02:06:01.000Z</published>
    <updated>2018-02-26T09:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前端面试题记录，包括ES5、ES6、CSS、前端框架、网络等等。</strong><br><a id="more"></a></p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><p>为了让手机也能获得良好的网页浏览体验，移动前端中常说的 viewport （视口）就是浏览器显示页面内容的屏幕区域。<br><b>使用viewport元标签控制布局:</b></p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>取值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td>正整数 或 device-width</td>
<td>定义视口的宽度，单位为像素</td>
</tr>
<tr>
<td>height</td>
<td>正整数 或 device-height</td>
<td>定义视口的高度，单位为像素，一般不用</td>
</tr>
<tr>
<td>initial-scale</td>
<td>[0.0-10.0]</td>
<td>定义初始缩放值</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>[0.0-10.0]</td>
<td>定义缩小最小比例，它必须小于或等于maximum-scale设置</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>[0.0-10.0]</td>
<td>定义放大最大比例，它必须大于或等于minimum-scale设置</td>
</tr>
<tr>
<td>user-scalable</td>
<td>yes/no</td>
<td>定义是否允许用户手动缩放页面，默认值yes</td>
</tr>
</tbody>
</table>
<p><b>怎样处理 移动端 1px 被 渲染成 2px :</b> </p>
<ol>
<li>局部处理<br> mate标签中的 viewport属性 ，initial-scale 设置为 1<br> rem 按照设计稿标准走，外加利用transfrome 的scale(0.5) 缩小一倍即可；</li>
<li>全局处理<br> mate标签中的 viewport属性 ，initial-scale 设置为 0.5<br> rem 按照设计稿标准走即可                </li>
</ol>
<h1 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h1><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p>所有引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除‘null’以外） 所有引用类型（数组、对象、函数），都具一个<em>proto</em> （隐式原型）属性，属性值是一个普通对象 所有函数，都有一个prototype（显式原型）属性，属性值也是一个普通对象 所有引用类型（数组、对象、函数），<em>proto</em> （隐式原型）属性值指向它的构造函数的prototype（显式原型）属性值 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<em>proto</em> （即它的构造函数的prototype）中寻找。</p>
<ol>
<li>普通对象与函数对象<br>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。</li>
<li>原型对象(原型prototype)<br>在JavaScript 中，每当定义一个对象（函数）时候，对象中都会包含一些预定义的属性。其中函数对象的一个属性就是显式原型prototype。注：普通对象没有prototype,但有<strong>proto</strong>属性。<br>原型对象其实就是普通对象（Function.prototype除外,它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;; obj.a = <span class="number">100</span>;</div><div class="line"><span class="keyword">var</span> arr = []; arr.a = <span class="number">100</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">fn.a = <span class="number">100</span>;  <span class="comment">// 所有引用类型都能拓展属性</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(obj.__proto__); <span class="comment">//constructor:f Object()</span></div><div class="line"><span class="built_in">console</span>.log(arr.__proto__); <span class="comment">//constructor:f Array()</span></div><div class="line"><span class="built_in">console</span>.log(fn.__proto__); <span class="comment">//f () &#123; [native code] &#125;</span></div><div class="line"><span class="comment">//所有引用类型都有_proto_（隐式原型）属性</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(obj.prototype); <span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.log(arr.prototype); <span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.log(fn.prototype); <span class="comment">//constructor: ƒ fn()</span></div><div class="line"><span class="comment">//所有函数，都有一个prototype（显式原型）属性</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype)</div><div class="line"><span class="comment">// true 引用类型_proto_（隐式原型）属性值指向它的构造函数的prototype（显式原型）属性值</span></div><div class="line"></div><div class="line"><span class="comment">//如果这个对象本身没有这个属性，那么会去它的*_proto_* （即它的构造函数的prototype）中寻找</span></div><div class="line"><span class="comment">//构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name)</div><div class="line">&#125;;</div><div class="line"><span class="comment">//创建实例</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'zhangsan'</span>);</div><div class="line">f.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line">f.printName(); <span class="comment">//f自身有printName这个属性，所以直接可以调用</span></div><div class="line">f.alertName(); <span class="comment">//f自身没有alertName这个属性,所以会去它的_proto_（即它的构造函数的prototype）中寻找</span></div><div class="line"><span class="built_in">console</span>.log(f.prototype)<span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.log(f.__proto__)<span class="comment">//constructor:ƒ Foo(name, age)</span></div><div class="line"><span class="built_in">console</span>.log(Foo.prototype)<span class="comment">//constructor:ƒ Foo(name, age)</span></div><div class="line"><span class="built_in">console</span>.log(Foo.__proto__)<span class="comment">//ƒ () &#123; [native code] &#125;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="闭包与作用域"><a href="#闭包与作用域" class="headerlink" title="闭包与作用域"></a>闭包与作用域</h2><p>闭包是有权限访问其他函数作用域内的变量的一个函数。即函数内部的函数，当内部函数被其外部函数之外的变量引用时，才会形成闭包.<br><b>为什么其他非闭包的函数没有权限访问另一个函数的内部作用域:</b><br>函数内部可以直接读取全局变量,在函数外部无法读取函数内的局部变量.<br><b>为什么闭包有这个权限:</b><br>子函数可以读取父函数的局部变量，再将子函数作为父函数的返回值，最终我们就得到了函数内部的局部变量。<br><b>什么是函数作用域:</b><br>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。<br><b>闭包的用途:</b><br>可以读取函数内部的变量；让变量的值始终保持在内存中；<br><b>经典案例:</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　<span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line">　　　　<span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;<span class="comment">//object.getNameFunc()是一个返回函数，没有var声明也是一个匿名函数，是全局变量，window调用</span></div><div class="line">　　alert(object.getNameFunc()());<span class="comment">//The Window</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line">　　<span class="keyword">var</span> object = &#123;</div><div class="line">　　　　<span class="attr">name</span> : <span class="string">"My Object"</span>,</div><div class="line">　　　　<span class="attr">getNameFunc</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="keyword">var</span> that = <span class="keyword">this</span>;<span class="comment">//this为object</span></div><div class="line">　　　　　　<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> that.name;</div><div class="line">　　　　　　&#125;;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;;<span class="comment">//that=this,this=object,so that=object;object调用</span></div><div class="line">　　alert(object.getNameFunc()());<span class="comment">//My Object</span></div></pre></td></tr></table></figure></p>
<h2 id="作用域：词法作用域，动态作用域"><a href="#作用域：词法作用域，动态作用域" class="headerlink" title="作用域：词法作用域，动态作用域"></a>作用域：词法作用域，动态作用域</h2><p>词法作用域：函数在定义的时候决定了函数的作用域，JavaScript采用词法作用域。<br>动态作用域：函数在调用的时候决定函数的作用域，目前只有部分语言支持。</p>
<p><b>JavaScript中函数作用域在定义的时候已经确定</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>; </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>; </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; </div><div class="line">        <span class="keyword">return</span> scope; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> fn(); </div><div class="line">&#125; </div><div class="line">checkScope();</div><div class="line"></div><div class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>; </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkScope</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>; </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; </div><div class="line">        <span class="keyword">return</span> scope; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> fn; </div><div class="line">&#125; </div><div class="line">checkScope()();</div><div class="line"><span class="comment">//区别就是函数fn的在不同位置执行，但这并不影响函数作用域，所以两个都是打印"local scope"</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> value = <span class="number">10</span>; </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="built_in">console</span>.log(value); </div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> value = <span class="number">20</span>; </div><div class="line">    foo(); </div><div class="line">&#125; </div><div class="line">bar();</div></pre></td></tr></table></figure>
<p>在词法作用域的情况下，函数foo在函数bar中调用，但其作用域在定义时已经确定，即只能访问到foo函数内部跟全局作用域,打印”10”；<br>在动态作用域的情况下，函数foo在函数bar中调用，其作用域在调用的时候确定，即只能访问到函数bar内部跟全局作用域，打印”20”。</p>
<h2 id="ES5与ES6中的this"><a href="#ES5与ES6中的this" class="headerlink" title="ES5与ES6中的this"></a>ES5与ES6中的this</h2><p><b>ES5中的this指向:</b><br>this 是你 call 一个函数时传的 context,如果你传的 context 是null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</p>
<ol>
<li>如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，非严格模式为undefined。</li>
<li>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</li>
<li><p>如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">a</span>:<span class="number">10</span>,</div><div class="line">    <span class="attr">b</span>:&#123;</div><div class="line">        <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//undefined</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">o.b.fn();<span class="comment">//因为this只会指向它的上一级对象b</span></div></pre></td></tr></table></figure>
</li>
<li><p>还有一种比较特殊的情况：这里this指向的是window,this永远指向的是最后调用它的对象:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">a</span>:<span class="number">10</span>,</div><div class="line">    <span class="attr">b</span>:&#123;</div><div class="line">        <span class="attr">a</span>:<span class="number">12</span>,</div><div class="line">        <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//undefined</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//window</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> j = o.b.fn;</div><div class="line">j();   <span class="comment">//调用对象是window，this指向window</span></div></pre></td></tr></table></figure>
</li>
<li><p>构造函数版this:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.user = <span class="string">"Caraxiong"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();</div><div class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//Caraxiong</span></div><div class="line"><span class="comment">//new关键字可以改变this的指向，将这个this指向对象a.调用这个函数Fn的是对象a，那么this指向的自然是对象a</span></div></pre></td></tr></table></figure>
</li>
<li><p>当this碰到return时:<br> 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例,还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">this</span>.user = <span class="string">'Caraxiong'</span>;  </div><div class="line">    <span class="keyword">return</span> &#123;&#125;;   <span class="comment">//返回一个对象</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </div><div class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">this</span>.user = <span class="string">'Caraxiong'</span>;  </div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;    <span class="comment">//返回一个对象</span></div><div class="line">&#125; </div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn; </div><div class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">this</span>.user = <span class="string">'Caraxiong'</span>;  </div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;    <span class="comment">//返回一个对象</span></div><div class="line">&#125; <span class="keyword">var</span> a = <span class="keyword">new</span> fn; <span class="built_in">console</span>.log(a.user); <span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">this</span>.user = <span class="string">'Caraxiong'</span>;  </div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//非对象</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </div><div class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//Caraxiong</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">this</span>.user = <span class="string">'Caraxiong'</span>;  </div><div class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;   <span class="comment">//非对象</span></div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn; </div><div class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//Caraxiong</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">this</span>.user = <span class="string">'Caraxiong'</span>;  </div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </div><div class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//Caraxiong</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p><b>ES6中的this指向:</b></p>
<ol>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</li>
<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a1 = <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.a2 = <span class="number">0</span>;</div><div class="line">  <span class="comment">// 箭头函数</span></div><div class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.a1++, <span class="number">1000</span>);</div><div class="line">  <span class="comment">// 普通函数</span></div><div class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a2++;</div><div class="line">  &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'a1: '</span>, timer.a1), <span class="number">3100</span>);</div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'a2: '</span>, timer.a2), <span class="number">3100</span>);</div><div class="line"><span class="comment">// a1: 3</span></div><div class="line"><span class="comment">// a2: 0</span></div></pre></td></tr></table></figure>
</li>
<li><p>上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。</p>
</li>
<li>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向</li>
<li>new操作符会改变函数this的指向问题，为什么this会指向a？<br><b>首先new关键字会创建一个空的对象，然后会自动调用一个函数apply方法，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代。</b></li>
</ol>
<h2 id="call，apply，bind-三者用法和区别"><a href="#call，apply，bind-三者用法和区别" class="headerlink" title="call，apply，bind 三者用法和区别"></a>call，apply，bind 三者用法和区别</h2><p>在js中所有的函数都是Function的实例，而且对于Function来说，它的原型即Function.prototype中含有很多东西，其中call,apply和bind方法就是Function原型中的方法，所以根据原型的规则，所有的函数都可以使用原型中属性和方法，所以来说，对于所有的函数都可以使用call，apply和bind方法。<br><b>作用:</b>改变this的指向<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">sex</span>)</span>&#123;  </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"普通函数"</span>+sex);  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">var</span> person=&#123;  </div><div class="line">    <span class="attr">name</span>:<span class="string">"aa"</span>,  </div><div class="line">    <span class="attr">age</span>:<span class="number">14</span>  </div><div class="line">&#125;;  </div><div class="line">show.call(person,<span class="string">"男"</span>);  </div><div class="line"><span class="comment">//person对象并没有show方法，但是我们可以通过call方法来实现person对象来调用show方法。所以这种情况我认为就是改变了this的指向,apply和bind方法也可以实现上述的功能.</span></div></pre></td></tr></table></figure></p>
<p><b>call,apply和bind的区别:</b><br>在功能上是没有区别的，都是改变this的指向，它们的区别主要是在于方法的实现形式和参数传递上的不同<br>函数.call(对象,arg1,arg2….)<br>函数.apply(对象，[arg1,arg2,…])<br>var ss=函数.bind(对象,arg1,arg2,….)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">sex</span>)</span>&#123;  </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"普通函数"</span>+sex);  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">var</span> person=&#123;  </div><div class="line">    <span class="attr">name</span>:<span class="string">"aa"</span>,  </div><div class="line">    <span class="attr">age</span>:<span class="number">14</span>  </div><div class="line">&#125;;  </div><div class="line">show.call(person,<span class="string">"男"</span>);  </div><div class="line">show.apply(person,[<span class="string">"女"</span>]);  </div><div class="line"><span class="comment">//对于bind来说，用法更加的灵活  </span></div><div class="line"><span class="keyword">var</span> ss=show.bind(person,<span class="string">"不明"</span>);  </div><div class="line">ss();</div></pre></td></tr></table></figure></p>
<h2 id="js的变量提升和函数提升"><a href="#js的变量提升和函数提升" class="headerlink" title="js的变量提升和函数提升"></a>js的变量提升和函数提升</h2><p>在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。变量提升即将变量声明提升到它所在作用域的最开始的部分<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    a =<span class="number">2</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="keyword">var</span> a;</div><div class="line">&#125;</div><div class="line">foo()<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p><b>函数提升:</b><br>js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升！如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum1</span>(<span class="params">n1,n2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> n1+n2;</div><div class="line">&#125;;<span class="comment">//函数声明</span></div><div class="line">  </div><div class="line"><span class="keyword">var</span> sum2=<span class="function"><span class="keyword">function</span>(<span class="params">n1,n2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> n1+n2;</div><div class="line">&#125;;<span class="comment">//函数表达式，又叫函数字面量</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(f1); <span class="comment">// function f1() &#123;&#125;   </span></div><div class="line"><span class="built_in">console</span>.log(f2); <span class="comment">// undefined  </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="comment">//实际执行过程如下：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 函数提升，整个代码块提升到文件的最开始&lt;br&gt;　　</span></div><div class="line"><span class="built_in">console</span>.log(f1);　　　  </div><div class="line"><span class="built_in">console</span>.log(f2);   </div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="let，const"><a href="#let，const" class="headerlink" title="let，const"></a>let，const</h2><p>let 产生块级作用域（通常配合 for 循环或者 {} 进行使用产生块级作用域），不存在变量提升，暂时性时区，不可重复声明;<br>const 申明的变量是常量（变量指向的那个内存地址不得改动)，特性同let</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。<br>Promise三种状态:pending（等待状态）、resolved（完成状态，又称fulfill）、rejected（已拒绝状态）<br>解决的痛点:解决了Callback Hell，就是我们熟悉的闭包或者说是回调函数，连续多级嵌套，导致代码结构的混乱<br>常用的 API :<br><b>Promise.all(iterable)</b>这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功<br><b>Promise.race(iterable)</b>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象<br><b>Promise.reject(reason)</b>返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法<br><b>Promise.resolve(value)</b>返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法</p>
<p><b>eventloop、microtask(微任务)、macrotask(宏任务) 的执行顺序：</b><br>微任务会在执行栈执行完后立即执行，而宏任务要等到下一次的event loop才会被执行；<br>promise属于Microtask队列，setTimeout属于task队列。这俩的异步队列不一样，Promise所在的那个异步队列优先级要高一些。</p>
<p><b>Promise 的链式调用:</b><br>then方法返回的是一个新的Promise实例,因此可以采用链式写法，即then方法后面再调用另一个then方法<br>也就是 promise().then().then().catch() 的形式,在程序中，只要返回了一个 promise 对象，如果 promise 对象不是 Rejected 或 Fulfilled 状态，then 方法就会继续调用。利用这个特性，可以处理多个异步逻辑。但有时候某个 then 方法的执行结果可能会决定是否需要执行下一个 then，这个时候就需中止 promise，主要思想就是使用 reject 来中止 promise 的 then 继续执行。</p>
<p><b>Promise实例的三个方法:</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// ···</span></div><div class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123; </div><div class="line">        <span class="comment">// ···</span></div><div class="line">        &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </div><div class="line">            <span class="comment">// ···</span></div><div class="line">            &#125;);</div></pre></td></tr></table></figure></p>
<ol>
<li>Promise.prototype.then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数</li>
<li>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<ol>
<li>Promise.prototype.finally()用于指定不管 Promise 对象最后状态如何，都会执行的操作</li>
</ol>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>遍历器对象生成函数，最大的特点是可以交出函数的执行权</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="左边定宽，右边自适应方案：float-margin，float-calc"><a href="#左边定宽，右边自适应方案：float-margin，float-calc" class="headerlink" title="左边定宽，右边自适应方案：float + margin，float + calc"></a>左边定宽，右边自适应方案：float + margin，float + calc</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 方案1 */</span></div><div class="line"><span class="selector-class">.left</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.right</span> &#123;</div><div class="line">  <span class="attribute">margin-left</span>: <span class="number">120px</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 方案2 */</span></div><div class="line"><span class="selector-class">.left</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.right</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(100% - 120px);</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="左右两边定宽，中间自适应：float，float-calc-圣杯布局（设置BFC，margin负值法），flex"><a href="#左右两边定宽，中间自适应：float，float-calc-圣杯布局（设置BFC，margin负值法），flex" class="headerlink" title="左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex"></a>左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.wrap</span> &gt; <span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 方案1 */</span></div><div class="line"><span class="selector-class">.left</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.right</span> &#123;</div><div class="line">  <span class="attribute">float</span>: right;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">120px</span>; </div><div class="line">&#125;</div><div class="line"><span class="comment">/* 方案2 */</span></div><div class="line"><span class="selector-class">.left</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.right</span> &#123;</div><div class="line">  <span class="attribute">float</span>: right;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(100% - 240px);</div><div class="line">  <span class="attribute">margin-left</span>: <span class="number">120px</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 方案3 最佳*/</span></div><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.left</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.right</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="左右居中"><a href="#左右居中" class="headerlink" title="左右居中"></a>左右居中</h2><p>行内元素: text-align: center；定宽块状元素: 左右 margin 值为 auto；不定宽块状元素: table布局，position + transform<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 方案1 */</span></div><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">  <span class="attribute">text-align</span>: center</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline;</div><div class="line">  <span class="comment">/* or */</span></div><div class="line">  <span class="comment">/* display: inline-block; */</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* 方案2 */</span></div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 方案3 */</span></div><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="上下垂直居中："><a href="#上下垂直居中：" class="headerlink" title="上下垂直居中："></a>上下垂直居中：</h2><p>定高：margin，position + margin(负值)；不定高：position + transform，flex，IFC + vertical-align:middle<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 定高方案1 */</span></div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;   </div><div class="line">&#125;</div><div class="line"><span class="comment">/* 定高方案2 */</span></div><div class="line"><span class="selector-class">.wrap</span>&#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 不定高方案1 */</span></div><div class="line"><span class="selector-class">.wrap</span>&#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 不定高方案2 */</span></div><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">align-items</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 不定高方案3 */</span></div><div class="line"><span class="comment">/* 设置 inline-block 则会在外层产生 IFC(内联格式化上下文)，高度设为 100% 撑开 wrap 的高度 */</span></div><div class="line"><span class="selector-class">.wrap</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">  <span class="attribute">text-align</span>: center; <span class="comment">/* 使得左右也居中 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.center</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;  </div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）"><a href="#盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）" class="headerlink" title="盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）"></a>盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）</h2><p><b>延伸： box-sizing</b></p>
<ol>
<li>content-box：默认值，宽度和高度分别应用到元素的内容框,在宽度和高度之外绘制元素的内边距和边框。</li>
<li>border-box：盒子宽度包含 padding 和 border，总宽度 = margin + width <b>常用</b></li>
<li>inherit：从父元素继承 box-sizing 属性</li>
</ol>
<h2 id="BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文"><a href="#BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文" class="headerlink" title="BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文"></a>BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文</h2><ol>
<li><p>BFC：块级格式化上下文，页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 BFC)。<br><b>BFC布局规则：</b><br>内部的Box会在<b>垂直方向</b>，一个接一个地放置。<br>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠<br>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。<br>BFC的区域不会与float box重叠，常用来清除浮动和布局。<br><b>产生 BFC 方式如下:</b><br>1、float 的值不为 none;<br>2、overflow 的值不为 visible。<br>3、position 的值不为 relative 和 static。<br>4、display 的值为 table-cell, table-caption, inline-block中的任何一个。<br><b>用处:</b>常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。</p>
</li>
<li><p>IFC：内联格式化上下文，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。<br>IFC中的line box一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同。 IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div ）会产生两个匿名块与 div 分隔开，即产生两个 IFC ，每个 IFC 对外表现为块级元素，与 div 垂直排列。<br><b>IFC布局规则：</b><br>框会从包含块的<b>顶部</b>开始，一个接一个地<b>水平</b>摆放。<br>摆放这些框的时候，它们在水平方向上的外边距、边框、内边距所占用的空间都会被考虑在内。在垂直方向上，这些框可能会以不同形式来对齐：它们可能会把底部或顶部对齐，也可能把其内部的文本基线对齐。能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框。水平的margin、padding、border有效，垂直无效。不能指定宽高。行框的宽度是由包含块和存在的浮动来决定。行框的高度由行高计算这一章所描述的规则来决定。行框一定会高到足以容纳它所包含的全部框。然而，它也可能比它所包含的最高的框还要高（例如：这些框是以基线对齐）。当框 B 的高度小于包含它的行框时，则 B 在行框中垂直对齐的位置由’vertical-align’ 属性来决定。当几个行级框在水平方向上无法塞得进同一个行框时，它们会被分布在两个或多个垂直堆放的行框中。行框会以既没有垂直间距 也没有重叠的方式被垂直堆放起来。通常，行框的左边紧贴其包含块的左边，而行框的右边紧贴其包含块的右边。然而，浮动框可以插在包含块边缘与行框边缘之间。因此，尽管在同一个IFC中的行框通常有同样的宽度（也就是其包含块的宽度），但它们的宽度也可能受浮动让水平可用空间减少的影响而有所改变。在同一个IFC中，行框的高度通常是变化的（例如：某一行包含了一个比较高的图片，而其它行只包含文本）。<br>当一行上的行级框的总宽度小于包含它们的行框的宽度，则它们在行框内的水平分布由’text-align’属性来决定。当一个行内框的宽度超过了行框的宽度，则它会被分割成几个框，而这些框会分布在几个行框。如果此行内框不可分割（例如：单个字符、或语言指定的文字打断规则不允许在此行内框中出现打断、或该行内框受 white-space 属性为 nowrap或 pre 的影响），那么该行内框溢出该行框。行内框被分割的时候，外边距、边框和内边距在出现分割的地方都没有视觉效果。<br><b>行高计算 ― ‘line-height’ 与 ‘vertical-align’ 属性:</b><br>计算行框里的各行内级框的高度。对于置换元素、行内块元素、行内表格元素来说，这是边界框的高度，对于行内框来说，这是其 ‘line-height’。<br>行内级元素根据其 ‘vertical-align’ 属性垂直对齐。<br>行框的高是最顶端框的顶边到最底端框的底边的距离。<br><b>line box:</b>行盒模型，这是一个显示区域，根据块状容器内，每一行的多个内联元素（inline-level element）都会共同生成一个行盒模型。<br><b>主要影响IFC内布局的css：</b><br>font-size:用来指定文本类型节点的大小,IFC内的很多属性的值是基于这个的;<br>line-height&amp;height:在一个由多个内联元素组成的块状容器内，’line-height’为内联元素的行盒模型指定了一个最低高度。 这个最低高度是分别由基线上的最小高度和基线下的最小深度组成。<br>vertical-aligin:该属性影响由多个内联元素生成的盒模型组成的行内盒模型的垂直定位。<br><b>用处:</b><br>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生IFC，通过 text-align 则可以使其水平居中。<br>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align: middle，其他行内元素则可以在此父元素下垂直居中</p>
</li>
<li><p>GFC：网格布局格式化上下文（display: grid）<br>GFC(GridLayout Formatting Contexts)直译为”网格布局格式化上下文”，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。<br>那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。</p>
</li>
<li><p>FFC：自适应格式化上下文（display: flex）<br>FFC(Flex Formatting Contexts)直译为”自适应格式化上下文”，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。<br>Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。<br>伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</p>
</li>
</ol>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="数据双向绑定原理"><a href="#数据双向绑定原理" class="headerlink" title="数据双向绑定原理"></a>数据双向绑定原理</h2><ol>
<li><p>vue：vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的；通过Object.defineProperty()来实现数据劫持的，Object.defineProperty( )可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，它对应了两个描述属性get和set，我们通过Object.defineProperty( )设置了对象Book的name属性，对其get和set进行重写操作，顾名思义，get就是在读取name属性这个值触发的函数，set就是在设置name属性这个值触发的函数，所以当执行 Book.name = ‘vue权威指南’ 这个语句时，控制台会打印出 “你取了一个书名叫做vue权威指南”，紧接着，当读取这个属性时，就会输出 “《vue权威指南》”，因为我们在get函数里面对该值做了加工了。</p>
</li>
<li><p>angularjs：双向数据绑定（bi-directional意味着如果视图改变了某个值，数据模型会通过脏检查观察到这个变化，而如果数据模型改变了某个值，视图也会依据变化重新渲染</p>
<ol>
<li>单向绑定ng-bind、双向绑定ng-model的区别：单向数据绑定用于数据显示，两者的区别在于页面没有加载完毕 ““会直接显示到页面，直到Angular渲染该绑定数据，这种行为有可能将”“让用户看到，而ng-bind则是在Angular渲染完毕后将数据显示；ng-model是双向数据绑定用于绑定值会变化的表单元素等。</li>
<li>$digest()：脏值检查循环；Anguar遍历完整个$watch列表，只要有任何值发生变化，应用将会退回到$watch循环中，直到检测不到有任何变化。 为什么再次运行这一循环，因为你更新了$watch列表中用于更新另一个值的值， Angular将检测不到更新，除非再次运行这个循环。</li>
<li>$watch：添加监听；对于所有绑定给同一$scope元素的UI对象，只会添加一个$watch到$watch列表中。这些$watch列表会在$digest循环中通过一个叫做“脏值检查”的程序解析</li>
<li>$apply：提供上下文执行表达式(Scope提供$apply方法传播Model的变化),AngularJS 外部的控制器（DOM 事件、外部的回调函数如 jQuery UI 空间等）调用了AngularJS 函数之后，必须调用$apply。在这种情况下，你需要命令 AngularJS 刷新自已（模型、视图等），$apply就是用来做这件事情的。我们在使用$apply这个方法的时候，只要可以，请把要执行的代码和函数传递给$apply 去执行，而不要自已执行那些函数然后再调用$apply。</li>
</ol>
</li>
<li><p>设计模式—订阅发布模式(Subscribe/Publish)</p>
</li>
</ol>
<h2 id="VDOM-vue"><a href="#VDOM-vue" class="headerlink" title="VDOM(vue)"></a>VDOM(vue)</h2><h2 id="vue、angularjs-和-react-区别"><a href="#vue、angularjs-和-react-区别" class="headerlink" title="vue、angularjs 和 react 区别"></a>vue、angularjs 和 react 区别</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前端面试题记录，包括ES5、ES6、CSS、前端框架、网络等等。&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javascript基础查漏补缺</title>
    <link href="http://yoursite.com/2018/01/25/javascript%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>http://yoursite.com/2018/01/25/javascript基础查漏补缺/</id>
    <published>2018-01-25T06:53:13.000Z</published>
    <updated>2018-02-24T05:52:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>把一些之前基础概念模糊的地方记录下来，查漏补缺，温故知新。</strong><br><a id="more"></a></p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="写入HTML输出-document-write"><a href="#写入HTML输出-document-write" class="headerlink" title="写入HTML输出:document.write"></a>写入HTML输出:document.write</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;This is a heading&lt;/h1&gt;"</span>);</div></pre></td></tr></table></figure>
<p>只能在 HTML 输出中使用 document.write。如果您在文档加载后使用该方法，会覆盖整个文档</p>
<h2 id="改变-HTML-样式"><a href="#改变-HTML-样式" class="headerlink" title="改变 HTML 样式"></a>改变 HTML 样式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x.style.color=<span class="string">"#ff0000"</span>;</div></pre></td></tr></table></figure>
<h2 id="JavaScript-splice"><a href="#JavaScript-splice" class="headerlink" title="JavaScript.splice()"></a>JavaScript.splice()</h2><p>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目<br>arrayObject.splice(index,howmany,item1,…..,itemX)<br>index    必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。<br>howmany    必需。要删除的项目数量。如果设置为 0，则不会删除项目。<br>item1, …, itemX    可选。向数组添加的新项目。<br><b>常用于table操作–编辑</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.dataTable.splice(<span class="keyword">this</span>.delIndex, <span class="number">1</span>, <span class="keyword">this</span>.formEdit)</div><div class="line"><span class="comment">//将表格数据中原有项删除，再将编辑表单项添加至表格数据</span></div><div class="line"><span class="keyword">this</span>.dataTable.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">this</span>.formEdit)</div><div class="line"><span class="comment">//将编辑表单项添加至表格数据位置为1的位置</span></div></pre></td></tr></table></figure></p>
<h2 id="JavaScript-slice"><a href="#JavaScript-slice" class="headerlink" title="JavaScript.slice()"></a>JavaScript.slice()</h2><p>slice() 方法可从已有的数组中返回选定的元素,<b>返回一个新的数组</b>,该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。<br>arrayObject.slice(start,end)<br>start    必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。<br>end        可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p>
<h2 id="JavaScript-unshift-shift"><a href="#JavaScript-unshift-shift" class="headerlink" title="JavaScript.unshift()/shift()"></a>JavaScript.unshift()/shift()</h2><p>unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度 ;shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。<br>arrayObject.unshift(newelement1,newelement2,….,newelementX)<br>newelement1    必需。向数组添加的第一个元素。<br>newelement2    可选。向数组添加的第二个元素。<br>newelementX    可选。可添加若干个元素。<br><b>常用于table操作–新增</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.dataTable.unshift(<span class="keyword">this</span>.formAdd)<span class="comment">//table操作--新增,将新增表单元素添加至表格数据</span></div><div class="line">arrayObject.shift()</div></pre></td></tr></table></figure></p>
<h2 id="JavaScript-reduce"><a href="#JavaScript-reduce" class="headerlink" title="JavaScript.reduce()"></a>JavaScript.reduce()</h2><p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br>reduce() 可以作为一个高阶函数，用于函数的 compose。<br><b>注意: </b>reduce() 对于空数组是不会执行回调函数的。<br>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)<br>total            必需。初始值, 或者计算结束后的返回值。<br>currentValue    必需。当前元素<br>currentIndex    可选。当前元素的索引<br>arr                可选。当前元素所属的数组对象。<br>initialValue    可选。传递给函数的初始值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">65</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">4</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">total, num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> total + num;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = numbers.reduce(getSum);</div><div class="line">&#125;</div><div class="line"><span class="comment">//数组平均数</span></div><div class="line"><span class="keyword">const</span> average = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>) / arr.length;</div><div class="line"><span class="comment">// average([1,2,3]) -&gt; 2</span></div><div class="line"><span class="comment">//计数数组中值的出现次数</span></div><div class="line"><span class="keyword">const</span> countOccurrences = <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> v === value ? a + <span class="number">1</span> : a + <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">// countOccurrences([1,1,2,1,2,3], 1) -&gt; 3</span></div></pre></td></tr></table></figure></p>
<h2 id="JavaScript-Array-filter"><a href="#JavaScript-Array-filter" class="headerlink" title="JavaScript Array.filter()"></a>JavaScript Array.filter()</h2><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br>注意： filter() 不会对空数组进行检测。<br>注意： filter() 不会改变原始数组。<br>array.filter(function(currentValue,index,arr), thisValue)<br>currentValue    必须。当前元素的值<br>index            可选。当期元素的索引值<br>arr                可选。当期元素属于的数组对象<br>thisValue        可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ages = [<span class="number">32</span>, <span class="number">33</span>, <span class="number">16</span>, <span class="number">40</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAdult</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> age &gt;= <span class="number">18</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = ages.filter(checkAdult);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="JavaScript-Array-toString"><a href="#JavaScript-Array-toString" class="headerlink" title="JavaScript Array.toString()"></a>JavaScript Array.toString()</h2><p>把数组转换为字符串,数组中的元素之间用逗号分隔<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</div><div class="line">arr[<span class="number">0</span>] = <span class="string">"George"</span></div><div class="line">arr[<span class="number">1</span>] = <span class="string">"John"</span></div><div class="line">arr[<span class="number">2</span>] = <span class="string">"Thomas"</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.write(arr.toString())<span class="comment">//George,John,Thomas</span></div></pre></td></tr></table></figure></p>
<h2 id="JavaScript-Array-map"><a href="#JavaScript-Array-map" class="headerlink" title="JavaScript Array map()"></a>JavaScript Array map()</h2><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值,map() 方法按照原始数组元素顺序依次处理元素。<br><b>注意： </b>map() 不会对空数组进行检测。<br><b>注意： </b>map() 不会改变原始数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span> number * <span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(doubled);<span class="comment">// [2, 4, 6, 8, 10]</span></div></pre></td></tr></table></figure></p>
<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="jQuery-merge"><a href="#jQuery-merge" class="headerlink" title="jQuery.merge()"></a>jQuery.merge()</h2><p>$.merge() 函数用于合并两个数组内容到第一个数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = $.merge( [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] );</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;把一些之前基础概念模糊的地方记录下来，查漏补缺，温故知新。&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue 依赖安装命令</title>
    <link href="http://yoursite.com/2018/01/24/vue-%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/01/24/vue-依赖安装命令/</id>
    <published>2018-01-24T08:10:16.000Z</published>
    <updated>2018-01-24T08:19:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>npm安装vue各项依赖的命令及在vue-cli创建项目里组件的引入</strong><br><a id="more"></a></p>
<h1 id="在vue-cli的组件模板里使用font-awesome"><a href="#在vue-cli的组件模板里使用font-awesome" class="headerlink" title="在vue-cli的组件模板里使用font-awesome"></a>在vue-cli的组件模板里使用font-awesome</h1><blockquote>
<p>npm install font-awesome</p>
<ul>
<li>在main.js里添加<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'font-awesome/css/font-awesome.css'</span></div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="在vue-cli的组件模板里使用Scss"><a href="#在vue-cli的组件模板里使用Scss" class="headerlink" title="在vue-cli的组件模板里使用Scss"></a>在vue-cli的组件模板里使用Scss</h1><ul>
<li><p>依次执行以下命令 安装node-sass和sass-loader</p>
<blockquote>
<p>npm install node-sass –save-dev<br>npm install sass-loader –save-dev</p>
</blockquote>
</li>
<li><p>修改相关webpack配置 打开webpack.base.config.js, 在module里的rules中加上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> test: /\.scss$/,</div><div class="line"> loaders : [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;],</div><div class="line"> include: [resolve(&apos;static&apos;), resolve(&apos;test&apos;)]</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
</li>
<li><p>如果要在vue文件中的style使用scss,则在 style处声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;style lang=&quot;sass&quot; scoped&gt;</div><div class="line">  @import &apos;login.scss&apos;;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="在vue-cli的组件模板里使用amaze-vue"><a href="#在vue-cli的组件模板里使用amaze-vue" class="headerlink" title="在vue-cli的组件模板里使用amaze-vue"></a>在vue-cli的组件模板里使用amaze-vue</h1><p>通过npm安装amaze-vue:</p>
<blockquote>
<p>npm install amaze-vue –save</p>
</blockquote>
<p>修改src/main.js 文件:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AmazeVue <span class="keyword">from</span> <span class="string">'amaze-vue'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'amaze-vue/dist/amaze-vue.css'</span>;</div><div class="line">Vue.use(AmazeVue);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;npm安装vue各项依赖的命令及在vue-cli创建项目里组件的引入&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git使用记录</title>
    <link href="http://yoursite.com/2018/01/10/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/01/10/git使用记录/</id>
    <published>2018-01-10T08:29:22.000Z</published>
    <updated>2018-01-11T05:43:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作过程中git的使用结合大神博客的总结和整理<br><a id="more"></a></p>
<h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><p><img src="/2018/01/10/git使用记录/1.png" alt="process"></p>
<ul>
<li>Workspace（工作区）：程序员进行开发改动的地方，是你当前看到的，也是最新的。</li>
<li>Index / Stage（暂存区）：.git目录下的index文件, 暂存区会记录git add添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用git status查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过git add先提交到暂存区，被git管理。                    </li>
<li>Repository（仓库区/本地仓库）：保存了对象被提交 过的各个版本，比起工作区和暂存区的内容，它要更旧一些。git commit后同步index的目录树到本地仓库，方便从下一步通过git push同步本地仓库与远程仓库的同步。</li>
<li>Remote（远程仓库）：远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。<br><b>小结:</b></li>
<li>任何对象都是在工作区中诞生和被修改；</li>
<li>任何修改都是从进入index区才开始被版本控制；</li>
<li>只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；</li>
<li>与协作者分享本地的修改，可以把它们push到远程仓库来共享。<br><img src="/2018/01/10/git使用记录/2.png" alt="sum"><h1 id="常用Git命令"><a href="#常用Git命令" class="headerlink" title="常用Git命令"></a>常用Git命令</h1><img src="/2018/01/10/git使用记录/3.png" alt="command"></li>
<li>HEAD<br>HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。<br><img src="/2018/01/10/git使用记录/4.png" alt="command"></li>
<li>add<br>主要实现将工作区修改的内容提交到暂存区，交由git管理。<br>git add .    添加当前目录的所有文件到暂存区<br>git add <dir>    添加指定目录到暂存区，包括子目录<br>git add <file1>    添加指定文件到暂存区</file1></dir></li>
<li>commit<br>主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。<br>git commit -m <message>    提交暂存区到本地仓库,message代表说明信息<br>git commit <file1> -m <message>    提交暂存区的指定文件到本地仓库<br>git commit –amend -m <message>    使用一次新的commit，替代上一次提交</message></message></file1></message></li>
<li>branch<br>涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。<br>git branch    列出所有本地分支<br>git branch -r    列出所有远程分支<br>git branch -a    列出所有本地分支和远程分支<br>git branch <branch-name>    新建一个分支，但依然停留在当前分支<br>git checkout -b <branch-name>    新建一个分支，并切换到该分支<br>git branch –track <branch><remote-branch>    新建一个分支，与指定的远程分支建立追踪关系<br>git checkout <branch-name>    切换到指定分支，并更新工作区<br>git branch -d <branch-name>    删除分支<br>git push origin –delete <branch-name>    删除远程分支</branch-name></branch-name></branch-name></remote-branch></branch></branch-name></branch-name></li>
<li>merge<br>merge命令把不同的分支合并起来。<br>git fetch <remote>    merge之前先拉一下远程仓库最新代码<br>git merge <branch>    合并指定分支到当前分支</branch></remote></li>
<li>rebase<br>rebase又称为衍合，是合并的另外一种选择。</li>
<li>reset<br>reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。<br>git reset —soft <commit>    只改变提交点，暂存区和工作目录的内容都不改变<br>git reset —mixed <commit>    改变提交点，同时改变暂存区的内容<br>git reset —hard <commit>    暂存区、工作区的内容都会被修改到与提交点完全一致的状态<br>git reset –hard HEAD    让工作区回到上次提交时的状态</commit></commit></commit></li>
<li><p>revert<br>git revert用一个新提交来消除一个历史提交所做的任何修改。<br><b>revert与reset的区别：</b><br>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。<br>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。<br>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</p>
</li>
<li><p>push<br>上传本地仓库分支到远程仓库分支，实现同步。<br>git push <remote><branch>    上传本地指定分支到远程仓库<br>git push <remote> –force    强行推送当前分支到远程仓库，即使有冲突<br>git push <remote> –all    推送所有分支到远程仓库</remote></remote></branch></remote></p>
</li>
<li>其他命令<br>git status    显示有变更的文件<br>git log    显示当前分支的版本历史<br>git diff    显示暂存区和工作区的差异<br>git diff HEAD    显示工作区与当前分支最新commit之间的差异<br>git cherry-pick <commit>    选择一个commit，合并进当前分支</commit></li>
</ul>
<h1 id="Git-文件状态"><a href="#Git-文件状态" class="headerlink" title="Git 文件状态"></a>Git 文件状态</h1><p>git status:</p>
<ul>
<li>untracked 新文件未加入版本管理</li>
<li>unmodify</li>
<li>modified</li>
<li>staged 用 git add 暂存<br><b>git diff –staged 或 git diff –cached 可查看已暂存文件和上次提交的区别</b></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作过程中git的使用结合大神博客的总结和整理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTML5.2变更内容</title>
    <link href="http://yoursite.com/2018/01/10/HTML5-2%E5%8F%98%E6%9B%B4%E5%86%85%E5%AE%B9/"/>
    <id>http://yoursite.com/2018/01/10/HTML5-2变更内容/</id>
    <published>2018-01-10T01:24:25.000Z</published>
    <updated>2018-01-10T03:08:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>在2017年12月14日W3C发布了HTML规范5.2更新版本,这个版本相对之前的版本来说有了一些增加和删除.<br><a id="more"></a></p>
<h1 id="新增的dialog元素"><a href="#新增的dialog元素" class="headerlink" title="新增的dialog元素"></a>新增的dialog元素</h1><p>帮助我们快速实现一个对话框.在HTML5.2中,你只需要这写:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">id</span>=<span class="string">"dialog"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是对话框标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是对话框内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>添加open属性让他显示:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">id</span>=<span class="string">"dialog"</span> <span class="attr">open</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>调用它的show()方法让他显示:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dialog = <span class="built_in">document</span>.querySelector(<span class="string">'#dialog'</span>).show();</div></pre></td></tr></table></figure></p>
<p>想要这个对话框隐藏,只需要调用这个dialog元素的close()方法即可<br>显示对话框的同时,有一个遮罩层的话，使用showModal()；注意一点的是open属性和showModal()不能同时使用</p>
<h1 id="支付请求API-—-allowpaymentrequest"><a href="#支付请求API-—-allowpaymentrequest" class="headerlink" title="支付请求API — allowpaymentrequest"></a>支付请求API — allowpaymentrequest</h1><p>在HTML5.2之前.对于支付请求的API是不能在iframe中来完成的.所以每次我们在进行移动支付时都需要跳转到另外一个支付页面才能完成付款.而现在,使用allowpaymentrequest属性应用在iframe上<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">allowpaymentrequest</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="在页面上同时使用多个main标签"><a href="#在页面上同时使用多个main标签" class="headerlink" title="在页面上同时使用多个main标签"></a>在页面上同时使用多个main标签</h1><p>而现在,随着单页面应用(SPA)的越来越流行.使得这一特性的已经不符合当下的实景,所以在HTML5.2中.在页面中同时出现多个<main>标签是被允许的.只要在同一时间内,只有一个<main>标签是对外显示的,其他所有都是被hidden属性隐藏的即可<br><b>此外要注意,隐藏<main>标签的方法必须是使用hidden属性才行.其它的如:display: none、透明的为0等方法不行.这会让<main>标签失去自己的语义和作用.</main></main></b></main></main></p>
<h1 id="被删除的属性和元素"><a href="#被删除的属性和元素" class="headerlink" title="被删除的属性和元素"></a>被删除的属性和元素</h1><p>被删除的元素<br>keygen：用于帮助生成表单的公钥<br>menu和menuitem：用于创建导航或上下文菜单<br>被删除的属性<br>Window.showModalDialog(): 创建并显示一个包含指定HTML文档的模态框。<br>插件API: 提供有关浏览器插件的信息 .<br>废弃的HTML头部声明<br>以下两种HTML的头部声明已在HTML中废弃<br>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “<a href="http://www.w3.org/TR/html4/strict.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a><br>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在2017年12月14日W3C发布了HTML规范5.2更新版本,这个版本相对之前的版本来说有了一些增加和删除.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebStorm 使用技巧</title>
    <link href="http://yoursite.com/2018/01/05/WebStorm-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/01/05/WebStorm-使用技巧/</id>
    <published>2018-01-05T02:15:58.000Z</published>
    <updated>2018-02-26T07:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>commond+shift+O :按照文件名查找文件<br>command + g 或者command + f在当前文件中查找<br>command + shift + f 在某文件夹下查找<br>command + r 替换</p>
<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>command + d 行复制<br>command + x 剪切行<br>ctrl + g 查找与当前选中的单词相同的单词<br>command + shift + ‘up/down方向键’ 上下移动选中的代码块<br>shift + enter 重新开始新的一行 （无论光标在何位置）<br>alt + ‘left/right方向键’ 以单词为单位移动光标<br>command + e 选择最近打开的文件<br>ctrl + tab 切换当前打开的文件<br>alt + ‘up/down方向键’ 向上/下选择代码块<br>command + 退格键 删除当前行</p>
<h1 id="view代码神器"><a href="#view代码神器" class="headerlink" title="view代码神器"></a>view代码神器</h1><p>command + p 显示参数信息<br>command + 点击 跳转到变量定义处<br>fn + alt + F7 查看当前变量在何处被调用过<br>fn+shift + F6 高级重命名变量<br>command + shift + c 复制当前文件的绝对路径<br>command + alt + l 格式化</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h1&gt;&lt;p&gt;commond+shift+O :按照文件名查找文件&lt;br&gt;command + g 或者command + f在当前文件中查找&lt;br&gt;com
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端疑惑记录</title>
    <link href="http://yoursite.com/2018/01/02/%E5%89%8D%E7%AB%AF%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/01/02/前端疑惑记录/</id>
    <published>2018-01-02T09:58:50.000Z</published>
    <updated>2018-04-08T09:37:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vertial-align-text-aligh对行内元素有效"><a href="#vertial-align-text-aligh对行内元素有效" class="headerlink" title="vertial-align,text-aligh对行内元素有效"></a>vertial-align,text-aligh对行内元素有效</h1><h1 id="Script-Error"><a href="#Script-Error" class="headerlink" title="Script Error"></a>Script Error</h1><p>是外部加载的JS 抛出异常的时候， 出于安全方面的考虑，js错误信息中可能包含一些敏感信息，比如用户名、权限提示等，希望能够把这类信息屏蔽。目前跨域的场景下会触发这种安全限制，window.onerror无法获得具体出错信息，而只能得到Script error.<br>解决ScriptError 问题：<br>响应头增加 access-control-allow-orgin （以下简称AC）<br>每个fucntion 包裹 try-catch<br>切面包裹入口函数， try-catch</p>
<h1 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a>“use strict”</h1><p><b>ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）,顾名思义，这种模式使得Javascript在更严格的条件下运行。</b></p>
<ol>
<li>优点<br>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;消除代码运行的一些不安全之处，保证代码运行的安全提高编译器效率，增加运行速度;为未来新版本的Javascript做好铺垫。<br>“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。</li>
<li><p>调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"这是严格模式。"</span>);<span class="comment">/* 针对单个脚本 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">　　　　"use strict"</span>;</div><div class="line">　　　　<span class="keyword">return</span> <span class="string">"这是严格模式。"</span>;</div><div class="line">　　&#125;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">notStrict</span>(<span class="params"></span>) </span>&#123;</div><div class="line">　　　　<span class="keyword">return</span> <span class="string">"这是正常模式。"</span>;</div><div class="line">　　&#125;<span class="comment">/* 针对单个函数 */</span></div></pre></td></tr></table></figure>
</li>
<li><p>语法与行为改变<br>3.1 全局变量显式声明：在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">　　v = <span class="number">1</span>; <span class="comment">// 报错，v未声明</span></div><div class="line">　　<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="comment">// 报错，i未声明</span></div><div class="line">　　&#125;<span class="comment">/* 严格模式下，变量都必须先用var命令声明，然后再使用。 */</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>3.2 禁止this关键字指向全局对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">return</span> !<span class="keyword">this</span>;</div><div class="line">　　&#125; </div><div class="line">　　<span class="comment">// 返回false，因为"this"指向全局对象，"!this"就是false</span></div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; </div><div class="line"><span class="meta">　　　　"use strict"</span>;</div><div class="line">　　　　<span class="keyword">return</span> !<span class="keyword">this</span>;</div><div class="line">　　&#125; </div><div class="line">　　<span class="comment">// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。</span></div></pre></td></tr></table></figure></p>
<p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。<br>3.3 禁止删除变量<br>严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">　　<span class="keyword">var</span> x;</div><div class="line">　　<span class="keyword">delete</span> x; <span class="comment">// 语法错误</span></div><div class="line">　　<span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;<span class="string">'x'</span>: &#123;</div><div class="line">　　　　　　<span class="attr">value</span>: <span class="number">1</span>,</div><div class="line">　　　　　　<span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">　　&#125;&#125;);</div><div class="line">　　<span class="keyword">delete</span> o.x; <span class="comment">// 删除成功</span></div></pre></td></tr></table></figure></p>
<p>3.4 对象不能有重名的属性<br>正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">　　<span class="keyword">var</span> o = &#123;</div><div class="line">　　　　<span class="attr">p</span>: <span class="number">1</span>,</div><div class="line">　　　　<span class="attr">p</span>: <span class="number">2</span></div><div class="line">　　&#125;; <span class="comment">// 语法错误</span></div></pre></td></tr></table></figure></p>
<p>3.5 函数不能有重名的参数<br>正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a, b</span>) </span>&#123; <span class="comment">// 语法错误</span></div><div class="line">　　　　<span class="keyword">return</span> ;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<h1 id="JS原型与原型链"><a href="#JS原型与原型链" class="headerlink" title="JS原型与原型链"></a>JS原型与原型链</h1><p>在JavaScript中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象,也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为原型链</p>
<ol>
<li>普通对象与函数对象<br>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。</li>
<li>原型对象(原型prototype)<br>在JavaScript 中，每当定义一个对象（函数）时候，对象中都会包含一些预定义的属性。其中函数对象的一个属性就是原型prototype。注：普通对象没有prototype,但有<strong>proto</strong>属性。<br>原型对象其实就是普通对象（Function.prototype除外,它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;; </div><div class="line"><span class="built_in">console</span>.log(f1.prototype) <span class="comment">//f1&#123;&#125; </span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1. prototype) <span class="comment">//Object </span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// Function，这个特殊 </span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype) <span class="comment">// Object </span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>从这句console.log(f1.prototype) //f1 {} 的输出就结果可以看出，f1.prototype就是f1的一个实例对象。就是在f1创建的时候,创建了一个它的实例对象并赋值给它的prototype，基本过程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> f1(); </div><div class="line">f1. prototype = temp;</div></pre></td></tr></table></figure></p>
<p>所以，Function.prototype为什么是函数对象就迎刃而解了，上文提到凡是new Function ()产生的对象都是函数对象，所以temp1是函数对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> temp1 = <span class="keyword">new</span> <span class="built_in">Function</span> (); </div><div class="line"><span class="built_in">Function</span>.prototype = temp1;</div></pre></td></tr></table></figure></p>
<p><b>原型对象是用来做什么的呢？主要作用是用于继承,共享它所包含的属性和方法</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123; </div><div class="line"><span class="keyword">this</span>.name = name </div><div class="line">&#125;; </div><div class="line">person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name; </div><div class="line">&#125; </div><div class="line"><span class="keyword">var</span> zjh = <span class="keyword">new</span> person(<span class="string">'zhangjiahao'</span>); </div><div class="line">zjh.getName(); <span class="comment">//zhangjiahao</span></div><div class="line"><span class="comment">// 通过给person.prototype设置了一个函数对象的属性，那有person实例（例中：zjh）出来的普通对象就继承了这个属性。</span></div></pre></td></tr></table></figure></p>
<p><b>prototype就是通过调用构造函数而创建的对象实例的原型对象。</b></p>
<ol>
<li>原型链<br>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<strong>proto</strong>的内置属性，用于指向创建它的函数对象的原型对象prototype。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(zjh.__proto__ === person.prototype) <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>同样，person.prototype对象也有<strong>proto</strong>属性，它指向创建它的函数对象（Object）的prototype<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(person.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>Object.prototype对象也有<strong>proto</strong>属性，但它比较特殊，为null<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></div></pre></td></tr></table></figure></p>
<p><b>我们把这个有<strong>proto</strong>串起来的直到Object.prototype.<strong>proto</strong>为null的链叫做原型链</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line">animal.price = <span class="number">2000</span>;<span class="comment">//</span></div><div class="line">dog.prototype = animal;</div><div class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(dog.price) <span class="comment">//为什么输出 undefined </span></div><div class="line"><span class="built_in">console</span>.log(tidy.price) <span class="comment">//为什么输出 2000</span></div><div class="line"><span class="comment">/* dog是函数对象，自生没有price属性，dog的__proto__是构造函数的prototype，为new Function()的prototype，Function()的prototype没有price属性所以undefined；</span></div><div class="line"> tidy是普通对象，自生没有price属性，tidy的__proto__是构造函数的prototype，为new dog()的prototype，dog的prototype为animal，而animal有price属性所以为2000.*/</div></pre></td></tr></table></figure></p>
<p><b>当在自生找不到某个属性或方法时，会在<strong>proto</strong>寻找原型上的属性或方法</b></p>
<h1 id="JavaScript的函数currying柯里化"><a href="#JavaScript的函数currying柯里化" class="headerlink" title="JavaScript的函数currying柯里化"></a>JavaScript的函数currying柯里化</h1><p><b>柯里化是指将使用多个参数的函数转换成一系列使用一个参数的函数的技术。</b><br>通用版本:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _args = [];</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">Array</span>.prototype.push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</div><div class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> multi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/* 简单应用 */</span></div><div class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, c; c = <span class="built_in">arguments</span>[i++];) &#123;</div><div class="line">        total += c;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> total;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> sum = currying(multi);  </div><div class="line">sum(<span class="number">100</span>,<span class="number">200</span>)(<span class="number">300</span>);</div><div class="line">sum(<span class="number">400</span>);</div><div class="line"><span class="built_in">console</span>.log(sum());     <span class="comment">// 1000  （空白调用时才真正计算）</span></div></pre></td></tr></table></figure></p>
<p>prototype 属性,这是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fun = <span class="built_in">Function</span>.prototype.bind()<span class="comment">// 这个函数是不具有 prototype 属性</span></div></pre></td></tr></table></figure></p>
<p>prototype(显式原型):当我们声明一个函数时，这个属性就被自动创建,并且这个属性的值是一个对象（也就是原型），只有一个属性 constructor,constructor 对应着构造函数，也就是 Foo。<br><em>proto</em>(隐式原型):每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 <em>proto</em> 来访问。因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 <em>proto</em> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。<br>new 的过程：</p>
<ol>
<li>新生成一个对象；</li>
<li>链接到原型；</li>
<li>绑定this；</li>
<li>返回新对象。</li>
</ol>
<h1 id="理解CSS中BFC-Block-Formatting-Context-块格式化上下文"><a href="#理解CSS中BFC-Block-Formatting-Context-块格式化上下文" class="headerlink" title="理解CSS中BFC(Block Formatting Context:块格式化上下文)"></a>理解CSS中BFC(Block Formatting Context:块格式化上下文)</h1><p><b>BFC是Web页面中盒模型布局的CSS渲染模式。它的定位体系属于常规文档流。</b></p>
<ol>
<li>触发BFC<br>根元素，浮动，绝对定位元素，inline-blocks, table-cells, table-captions,flex,inline-flex,和overflow的值不为visible的元素，（除了这个值已经被传到了视口的时候）将创建一个新的块级格式化上下文。<br><b>创建一个新的BFC的最佳方案：”overflow: hidden”</b></li>
<li>BFC导致的外边距折叠<br>BFC里：理论上两个兄弟元素之间的边距应该是来两个元素的边距之和（20px），但它实际上为10px。这就是被称为外边距折叠。当兄弟元素的外边距不一样时，将以最大的那个外边距为准。当然垂直外边距折叠只有他们是在同一BFC时才会发生</li>
<li>使用BFC来防止外边距折叠<br>如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Sibling 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Sibling 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"newBFC"</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Sibling 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">background-color</span>: red; <span class="attribute">overflow</span>: hidden; <span class="comment">/* creates a block formatting context */</span> &#125; </div><div class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>; <span class="attribute">background-color</span>: lightgreen; &#125; </div><div class="line"><span class="selector-class">.newBFC</span> &#123; <span class="attribute">overflow</span>: hidden; <span class="comment">/* creates new block formatting context */</span> &#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>使用BFC来包含浮动<br>一个容器里有浮动元素。由于这个原因，容器元素没有高度，它的浮动孩子将会脱离页面的常规流。我们通常使用清除浮动来解决这个问题，最受欢迎的方法是使用一个clearfix的伪类元素。但我们同样可以通过定义一个BFC来达到这个目的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">overflow</span>: hidden; <span class="comment">/* creates block formatting context */</span> <span class="attribute">background-color</span>: green; &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用BFC来防止文字环绕</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"floated"</span>&gt;</span>Floated div<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Quae hic ut ab perferendis sit quod architecto,dolor debitis quam rem provident aspernatur tempora expedita.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">overflow</span>: hidden;&#125;</div></pre></td></tr></table></figure>
<h1 id="TCP协议中的三次握手和四次挥手"><a href="#TCP协议中的三次握手和四次挥手" class="headerlink" title="TCP协议中的三次握手和四次挥手"></a>TCP协议中的三次握手和四次挥手</h1><p><b>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号 并交换 TCP窗口大小信息。</b></p>
<ol>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x;然后，客户端进入SYN_SEND状态，等待服务器的确认;</li>
<li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1);同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态;</li>
<li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br><b>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。</b></li>
<li>第一次挥手：主机1(可以使客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段;此时，主机1进入FIN_WAIT_1状态;这表示主机1没有数据要发送给主机2了;</li>
<li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1;主机1进入FIN_WAIT_2状态;主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了;</li>
<li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态;</li>
<li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。<h1 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h1>https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</li>
<li>HTTP 是不安全的，而 HTTPS 是安全的</li>
<li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li>
<li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 工作在传输层</li>
<li>HTTP 无法加密，而HTTPS 对传输的数据进行加密</li>
<li>HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书</li>
</ol>
<h1 id="setTimeout-和setInterval"><a href="#setTimeout-和setInterval" class="headerlink" title="setTimeout()和setInterval()"></a>setTimeout()和setInterval()</h1><p>setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式；而setInterval()则可以在每隔指定的毫秒数<b>循环</b>调用函数或表达式，直到clearInterval把它清除。<br>setTimeout(code,millisec)、setInterval(code,millisec[,”lang”])<br>setInterval只要一次计时完毕，插入回调之后不管回调执不执行就开始计时，这会出现一种情况，当我们插入回调的时候前队列有别的代码在执行。setInterval如果第一个函数的执行时间特别长，在执行的过程中本应触发了许多个func，这些func并不会都进入队列，只要发现队列中有一个被执行的函数存在，那么其他的统统忽略。<b>在setInterval的里指定的周期是100毫秒，但它并不能保证两个函数之间调用的间隔一定是一百毫秒。<b><br>保证每次执行的间隔相同：用setTimeout</b></b></p>
<h1 id="js中的栈-堆和基本数据类型-引用类型"><a href="#js中的栈-堆和基本数据类型-引用类型" class="headerlink" title="js中的栈/堆和基本数据类型/引用类型"></a>js中的栈/堆和基本数据类型/引用类型</h1><ol>
<li>栈(stack)与堆(heap)<br>stack为自动分配的内存空间，由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。</li>
<li>基本类型与引用类型</li>
</ol>
<ul>
<li><b>基本类型：</b>存放在栈内存中的简单数据段，数据大小可以确定，内存空间大小可以分配；<br>五种基本数据类型有：undefined、Number、String、Boolean、Null，它们都是按值存放，所以可以直接访问。</li>
<li><b>引用类型：</b>存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况进行特定的分配。<br>当我们需要访问引用类型（对象、数组、函数等）时，首先从栈中获得该对象的地址指针，然后再从堆内存中访问所需数据。</li>
</ul>
<ol>
<li>传值与传址<br>基本类型与引用类型最大的区别是传值与传址的区别。</li>
</ol>
<ul>
<li>浅拷贝<br>在定义一个对象或数组时，变量存放的往往只是一个地址。当我们使用对象拷贝时，如果属性是对象或数组时，这时候我们传递的也只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间。</li>
<li>深拷贝<br>我们不希望父子对象之间产生关联，那么这时候可以用到深拷贝。既然属性值类型是数组和或象时只会传址，那么我们就用递归来解决这个问题，把父对象中所有属于对象的属性类型都遍历赋给子对象即可。</li>
</ul>
<h1 id="浏览器缓存知识总结"><a href="#浏览器缓存知识总结" class="headerlink" title="浏览器缓存知识总结"></a>浏览器缓存知识总结</h1><p>浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数web开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。</p>
<h2 id="浏览器缓存基本认识"><a href="#浏览器缓存基本认识" class="headerlink" title="浏览器缓存基本认识"></a>浏览器缓存基本认识</h2><p>浏览器缓存分为强缓存和协商缓存：</p>
<ol>
<li>浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；</li>
<li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</li>
<li>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</li>
<li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</li>
</ol>
<h2 id="强缓存的原理"><a href="#强缓存的原理" class="headerlink" title="强缓存的原理"></a>强缓存的原理</h2><p>当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache。强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。<br>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新；</li>
</ol>
<p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</li>
</ol>
<p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。</p>
<h2 id="强缓存的管理"><a href="#强缓存的管理" class="headerlink" title="强缓存的管理"></a>强缓存的管理</h2><p>在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存：</p>
<ol>
<li>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li>
<li>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</li>
</ol>
<p>开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：</p>
<ol>
<li>直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；</li>
<li>使用浏览器的隐私模式开发；</li>
<li>如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）；</li>
<li>在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；</li>
<li>如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面；</li>
<li>如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数；</li>
<li>还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题；</li>
<li>如果你用的是grunt和gulp这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存。</li>
</ol>
<h2 id="强缓存的应用"><a href="#强缓存的应用" class="headerlink" title="强缓存的应用"></a>强缓存的应用</h2><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年。<br>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。不过现在已经有很多前端工具能够实际地解决这个问题。</p>
<h2 id="协商缓存的原理"><a href="#协商缓存的原理" class="headerlink" title="协商缓存的原理"></a>协商缓存的原理</h2><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。<br>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。<br>【Last-Modified，If-Modified-Since】的控制缓存的原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间；</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值；</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header；</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源；</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值；</li>
</ol>
<p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题;</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值;</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化;</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
</ol>
<h2 id="协商缓存的管理"><a href="#协商缓存的管理" class="headerlink" title="协商缓存的管理"></a>协商缓存的管理</h2><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache。<br>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：</p>
<ol>
<li>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</li>
<li>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）。</li>
</ol>
<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>
<h2 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h2><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变。</p>
<ol>
<li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vertial-align-text-aligh对行内元素有效&quot;&gt;&lt;a href=&quot;#vertial-align-text-aligh对行内元素有效&quot; class=&quot;headerlink&quot; title=&quot;vertial-align,text-aligh对行内元素有
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css3新特性最佳实践</title>
    <link href="http://yoursite.com/2017/12/27/css3%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/12/27/css3新特性最佳实践/</id>
    <published>2017-12-27T07:16:47.000Z</published>
    <updated>2017-12-27T07:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过渡-transition"><a href="#过渡-transition" class="headerlink" title="过渡(transition)"></a>过渡(transition)</h1><p>transition: CSS属性,花费时间,效果曲线(默认ease),延迟时间(默认0)<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间5秒，0.2秒后执行过渡*/</span></div><div class="line"><span class="selector-class">.btn</span>&#123;</div><div class="line"><span class="comment">/*宽度从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒，0.2秒后执行过渡*/</span></div><div class="line"><span class="attribute">transition</span>:width,.<span class="number">5s</span>,ease,.<span class="number">2s</span>;</div><div class="line"><span class="comment">/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/</span></div><div class="line"><span class="attribute">transition</span>:all,.<span class="number">5s</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li><p>hover效果(button)</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:hover</span>&#123;</div><div class="line">    <span class="attribute">transition</span>: all .<span class="number">5s</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>下拉菜单(显示下拉)<br>设置ul的过渡.ul-transition ul{transform-origin: 0 0;transition: all .5s;}</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.ul-transition</span> <span class="selector-tag">ul</span>&#123;</div><div class="line">    <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</div><div class="line">    <span class="attribute">transition</span>: all .<span class="number">5s</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;过渡-transition&quot;&gt;&lt;a href=&quot;#过渡-transition&quot; class=&quot;headerlink&quot; title=&quot;过渡(transition)&quot;&gt;&lt;/a&gt;过渡(transition)&lt;/h1&gt;&lt;p&gt;transition: CSS属性,花费时间,效
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>伪元素小技巧</title>
    <link href="http://yoursite.com/2017/12/27/%E4%BC%AA%E5%85%83%E7%B4%A0%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/12/27/伪元素小技巧/</id>
    <published>2017-12-27T06:39:58.000Z</published>
    <updated>2018-03-27T02:15:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前面-后面添加图片"><a href="#前面-后面添加图片" class="headerlink" title="前面/后面添加图片"></a>前面/后面添加图片</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">content</span>: <span class="built_in">url</span>(../img/nav_fg.png);&#125;</div></pre></td></tr></table></figure>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.clearfix:after&#123;</div><div class="line">    content:"";</div><div class="line">    height:0;</div><div class="line">    line-height:0;</div><div class="line">    display:block;</div><div class="line">    visibility:hidden;</div><div class="line">    clear:both ;</div><div class="line">&#125;</div><div class="line">.clearfix&#123;</div><div class="line">    *zoom:1;/* IE6/IE7 */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="画分割线"><a href="#画分割线" class="headerlink" title="画分割线"></a>画分割线</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span>&#123;</div><div class="line">    <span class="attribute">margin-top</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:after</span>,<span class="selector-tag">p</span><span class="selector-pseudo">:before</span>&#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h1><ol>
<li>counter-reset: 属性创建或者重置一个或多个计数器；</li>
<li>counter-increment: 属性递增一个或多个计数器值；</li>
<li>content: 与:before 及:after 伪元素配合使用，来插入生成内容。<br><img src="/2017/12/27/伪元素小技巧/1.png" alt="1"><h1 id="css绘制平行四边形"><a href="#css绘制平行四边形" class="headerlink" title="css绘制平行四边形"></a>css绘制平行四边形</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.button</span> &#123;</div><div class="line">	<span class="attribute">position</span>: relative;</div><div class="line">	<span class="attribute">display</span>: inline-block;</div><div class="line">	<span class="attribute">padding</span>: .<span class="number">5em</span> <span class="number">1em</span>;</div><div class="line">	<span class="attribute">border</span>: <span class="number">0</span>; <span class="attribute">margin</span>: .<span class="number">5em</span>;</div><div class="line">	<span class="attribute">background</span>: transparent;</div><div class="line">	<span class="attribute">color</span>: white;</div><div class="line">	<span class="attribute">text-transform</span>: uppercase;</div><div class="line">	<span class="attribute">text-decoration</span>: none;</div><div class="line">	<span class="attribute">font</span>: bold <span class="number">200%</span>/<span class="number">1</span> sans-serif;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.button</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">	<span class="attribute">content</span>: <span class="string">''</span>; <span class="comment">/* To generate the box */</span></div><div class="line">	<span class="attribute">position</span>: absolute;</div><div class="line">	<span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">z-index</span>: -<span class="number">1</span>;</div><div class="line">	<span class="attribute">background</span>: <span class="number">#58a</span>;</div><div class="line">	<span class="attribute">transform</span>: <span class="built_in">skew</span>(45deg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="梯形标签页-tab页切换"><a href="#梯形标签页-tab页切换" class="headerlink" title="梯形标签页(tab页切换)"></a>梯形标签页(tab页切换)</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">	<span class="attribute">padding</span>: <span class="number">40px</span>;</div><div class="line">	<span class="attribute">font</span>: <span class="number">130%</span>/<span class="number">2</span> Frutiger LT Std, sans-serif;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span> &#123;</div><div class="line">	<span class="attribute">position</span>: relative;</div><div class="line">	<span class="attribute">z-index</span>: <span class="number">1</span>;</div><div class="line">	<span class="attribute">padding-left</span>: <span class="number">1em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span> &gt; <span class="selector-tag">a</span> &#123;</div><div class="line">	<span class="attribute">position</span>: relative;</div><div class="line">	<span class="attribute">display</span>: inline-block;</div><div class="line">	<span class="attribute">padding</span>: .<span class="number">3em</span> <span class="number">1em</span> <span class="number">0</span>;</div><div class="line">	<span class="attribute">color</span>: inherit;</div><div class="line">	<span class="attribute">text-decoration</span>: none;</div><div class="line">	<span class="attribute">margin</span>: <span class="number">0</span> -.<span class="number">3em</span>;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="selector-tag">nav</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">::before</span>,</div><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line">	<span class="attribute">border</span>: .<span class="number">1em</span> solid <span class="built_in">rgba</span>(0,0,0,.4);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">	<span class="attribute">content</span>: <span class="string">''</span>; <span class="comment">/* To generate the box */</span></div><div class="line">	<span class="attribute">position</span>: absolute;</div><div class="line">	<span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">	<span class="attribute">z-index</span>: -<span class="number">1</span>;</div><div class="line">	<span class="attribute">border-bottom</span>: none;</div><div class="line">	<span class="attribute">border-radius</span>: .<span class="number">5em</span> .<span class="number">5em</span> <span class="number">0</span> <span class="number">0</span>;</div><div class="line">	<span class="attribute">background</span>: <span class="number">#ccc</span> <span class="built_in">linear-gradient</span>(hsla(0,0%,100%,.6), <span class="built_in">hsla</span>(0,0%,100%,0));</div><div class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> .<span class="number">15em</span> white inset;</div><div class="line">	<span class="attribute">transform</span>: <span class="built_in">scale</span>(1.1, 1.3) <span class="built_in">perspective</span>(.5em) <span class="built_in">rotateX</span>(5deg);</div><div class="line">	<span class="attribute">transform-origin</span>: bottom;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-class">.selected</span> &#123; <span class="attribute">z-index</span>: <span class="number">2</span>;&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-class">.selected</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">	<span class="attribute">background-color</span>: <span class="number">#eee</span>;</div><div class="line">	<span class="attribute">margin-bottom</span>: -.<span class="number">08em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line">	<span class="attribute">display</span>: block;</div><div class="line">	<span class="attribute">margin-bottom</span>: <span class="number">1em</span>;</div><div class="line">	<span class="attribute">background</span>: <span class="number">#eee</span>;</div><div class="line">	<span class="attribute">padding</span>: <span class="number">1em</span>;</div><div class="line">	<span class="attribute">border-radius</span>: .<span class="number">15em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span><span class="selector-class">.left</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">	<span class="attribute">transform</span>: <span class="built_in">scale</span>(1.2, 1.3) <span class="built_in">perspective</span>(.5em) <span class="built_in">rotateX</span>(5deg);</div><div class="line">	<span class="attribute">transform-origin</span>: bottom left;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span><span class="selector-class">.right</span> &#123; <span class="attribute">padding-left</span>: <span class="number">2em</span>; &#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span><span class="selector-class">.right</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">	<span class="attribute">transform</span>: <span class="built_in">scale</span>(1.2, 1.3) <span class="built_in">perspective</span>(.5em) <span class="built_in">rotateX</span>(5deg);</div><div class="line">	<span class="attribute">transform-origin</span>: bottom right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"selected"</span>&gt;</span>Projects<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">	Content area</div><div class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"selected"</span>&gt;</span>Projects<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">	Content area</div><div class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"selected"</span>&gt;</span>Projects<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">	Content area</div><div class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前面-后面添加图片&quot;&gt;&lt;a href=&quot;#前面-后面添加图片&quot; class=&quot;headerlink&quot; title=&quot;前面/后面添加图片&quot;&gt;&lt;/a&gt;前面/后面添加图片&lt;/h1&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css技巧记录</title>
    <link href="http://yoursite.com/2017/12/25/css%E6%8A%80%E5%B7%A7%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2017/12/25/css技巧记录/</id>
    <published>2017-12-25T08:35:56.000Z</published>
    <updated>2018-01-11T09:04:56.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: css技巧记录<br>date: 2017-12-25 16:00:07</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><p>1、 使用CSS复位<br>在不同的浏览器上保持一致的样式风格<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">  box-sizing: border-box;//box-sizing管理CSS盒模型布局</div><div class="line">  margin: 0;</div><div class="line">  padding: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、 使用 :not() 选择器来决定表单是否显示边框<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 添加边框 */</span></div><div class="line"><span class="selector-class">.nav</span> <span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-child)</span> &#123;</div><div class="line">  <span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="number">#666</span>;</div><div class="line">&#125;<span class="comment">/* .nav li + li或者 .nav li:first-child ~ li  */</span></div></pre></td></tr></table></figure></p>
<p>3、 为 body 元素添加行高(在body里面同一行高)<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</div><div class="line">&#125;<span class="comment">/* 不必为每一个 &lt;p&gt;，&lt;h*&gt; 元素逐一添加 line-height，直接添加到 body 元素 ,文本元素可以很容易地继承 body 的样式*/</span></div></pre></td></tr></table></figure></p>
<p>4、 垂直居中任何元素<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">-webkit-align-items</span>: center;  </div><div class="line">  <span class="attribute">-ms-flex-align</span>: center;  </div><div class="line">  <span class="attribute">align-items</span>: center;</div><div class="line">  <span class="attribute">display</span>: -webkit-flex;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、 逗号分隔列表<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-child)</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="string">","</span>;</div><div class="line">&#125;<span class="comment">/* 使列表的每项都由逗号分隔 */</span></div></pre></td></tr></table></figure></p>
<p>6、 使用负的 nth-child 来选择元素</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 使用负的 nth-child 可以选择 1 至 n 个元素 */</span></div><div class="line"><span class="comment">/* 方法一 */</span></div><div class="line"><span class="selector-tag">li</span> &#123;</div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 选择第 1 至第 3 个元素并显示出来 */</span></div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(-n+3)</span> &#123;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 方法二 */</span></div><div class="line"><span class="comment">/* 选择第 1 至第 3 个元素并显示出来 */</span></div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:nth-child(-n+3))</span> &#123;</div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>7、 使用 SVG 图标<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.logo</span> &#123;</div><div class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"logo.svg"</span>);</div><div class="line">&#125;<span class="comment">/* SVG 在所有分辨率下都可以良好缩放，并且支持所有 IE9 以后的浏览器 */</span></div><div class="line"><span class="comment">/* 针对仅有图标的按钮，如果 SVG 没有加载成功的话，以下样式对无障碍有所帮助 */</span></div><div class="line"><span class="selector-class">.no-svg</span> <span class="selector-class">.icon-only</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(aria-label);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>8、 通用选择器 (*) 和 相邻兄弟选择器 (+) 一起使用<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* + * &#123;</div><div class="line">  <span class="attribute">margin-top</span>: <span class="number">1.5em</span>;</div><div class="line">&#125;<span class="comment">/* 文档流中的所有的相邻兄弟元素将都将设置 margin-top: 1.5em 的样式 */</span></div></pre></td></tr></table></figure></p>
<p>9、 使用 max-height 来建立纯 CSS 的滑块<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.slider</span> &#123;</div><div class="line">  <span class="attribute">max-height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">overflow-y</span>: hidden;</div><div class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.slider</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">max-height</span>: <span class="number">600px</span>;</div><div class="line">  <span class="attribute">overflow-y</span>: scroll;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>10、 创造格子等宽的表格<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.calendar</span> &#123;</div><div class="line">  <span class="attribute">table-layout</span>: fixed;</div><div class="line">&#125;<span class="comment">/* table-layout: fixed 可以让每个格子保持等宽 */</span></div></pre></td></tr></table></figure></p>
<p>11、 利用 Flexbox 去除多余的外边距<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">justify-content</span>: space-between;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.list</span> <span class="selector-class">.person</span> &#123;</div><div class="line">  <span class="attribute">flex-basis</span>: <span class="number">23%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>12、 利用 Flexbox 去除多余的外边距<br>与其使用 nth-， first-， 和 last-child 去除列之间多余的间隙，不如使用 flexbox 的 space-between 属性：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list</span> &#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">justify-content</span>: space-between;<span class="comment">/* 定义项目在主轴上的对齐方式:两端对齐，项目之间的间隔相等 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.list</span> <span class="selector-class">.person</span> &#123;</div><div class="line">  <span class="attribute">flex-basis</span>: <span class="number">23%</span>;<span class="comment">/* 定义在分配多余空间之前，项目占据的主轴空间 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>13、 利用属性选择器来选择空链接<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="http"]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(href);</div><div class="line">&#125;<span class="comment">/* 当 &lt;a&gt; 元素没有文本内容，但有 href 属性的时候，显示它的 href 属性 */</span></div></pre></td></tr></table></figure></p>
<p>14、 给 “默认” 链接定义样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[class]</span>) &#123;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#008000</span>;</div><div class="line">  <span class="attribute">text-decoration</span>: underline;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>15、 一致垂直节奏<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.intro</span> &gt; * &#123;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">1.25rem</span>;</div><div class="line">&#125;<span class="comment">/* 通用选择器 (*) 跟元素一起使用，可以保持一致的垂直节奏 */</span></div></pre></td></tr></table></figure></p>
<p>16、 固定比例盒子<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123;</div><div class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding-bottom</span>: <span class="number">20%</span>;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">2px</span> dashed <span class="number">#ddd</span>;  </div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;<span class="comment">/* 使用20％的padding-bottom使得框等于其宽度的20％的高度。与视口宽度无关，子元素的div将保持其宽高比（100％/ 20％= 5:1） */</span></div></pre></td></tr></table></figure></p>
<p>17、 为破碎图象定义样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123;  </div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">font-family</span>: Helvetica, Arial, sans-serif;</div><div class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span>;</div><div class="line">  <span class="attribute">height</span>: auto;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">2</span>;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;<span class="comment">/* 以添加伪元素的法则来显示用户信息和URL的引用： */</span></div><div class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:before</span> &#123;  </div><div class="line">  <span class="attribute">content</span>: <span class="string">"We're sorry, the image below is broken :("</span>;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:after</span> &#123;  </div><div class="line">  <span class="attribute">content</span>: <span class="string">"(url: "</span> <span class="built_in">attr</span>(src) <span class="string">")"</span>;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>18、 用 rem 来调整全局大小；用 em 来调整局部大小<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h2</span> &#123; <span class="comment">/* 在根元素设置基本字体大小后 (html &#123; font-size: 100%; &#125;), 使用 em 设置文本元素的字体大小: */</span></div><div class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</div><div class="line">&#125;<span class="comment">/* 然后设置模块的字体大小为 rem： */</span></div><div class="line"><span class="selector-tag">article</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">1.25rem</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">aside</span> <span class="selector-class">.module</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: .<span class="number">9rem</span>;</div><div class="line">&#125;<span class="comment">/* 现在，每个模块变得独立，更容易、灵活的样式便于维护。 */</span></div></pre></td></tr></table></figure></p>
<p>19、 隐藏没有静音、自动播放的影片<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">video</span><span class="selector-attr">[autoplay]</span><span class="selector-pseudo">:not(</span><span class="selector-attr">[muted]</span>) &#123;<span class="comment">/* 避免在加载页面时自动播放。如果没有静音，则不显示视频： */</span></div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>20、 使用选择器:root来控制字体弹性<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:root</span> &#123;<span class="comment">/* 在响应式布局中，字体大小应需要根据不同的视口进行调整。你可以计算字体大小根据视口高度的字体大小和宽度，这时需要用到:root: */</span></div><div class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(1vw + 1vh + .5vmin);</div><div class="line">&#125;<span class="comment">/* 现在，您可以使用 root em： */</span></div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">  <span class="attribute">font</span>: <span class="number">1rem</span>/<span class="number">1.6</span> sans-serif;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>21、 为更好的移动体验，为表单元素设置字体大小<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="text"]</span>,</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="number"]</span>,</div><div class="line"><span class="selector-tag">select</span>,</div><div class="line"><span class="selector-tag">textarea</span> &#123;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</div><div class="line">&#125;<span class="comment">/* 当触发&lt;select&gt;的下拉列表时，为了避免表单元素在移动浏览器（ios Safari 等等）上的缩放，加上font-size： */</span></div></pre></td></tr></table></figure></p>
<p>22、 使用text-indent来隐藏文本<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span> &#123;<span class="comment">/* 使用“text-indent”我们可以达到图片替换文本的效果，而且方便搜索引擎的优化，还能支持阅读器阅读网页内容 */</span></div><div class="line">       <span class="attribute">text-indent</span>:-<span class="number">9999px</span>;</div><div class="line">    <span class="attribute">margin</span>:<span class="number">0</span> auto;</div><div class="line">    <span class="attribute">width</span>:<span class="number">400px</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</div><div class="line">    <span class="attribute">background</span>:transparent <span class="built_in">url</span>(<span class="string">"images/logo.jpg"</span>) no-repeat scroll;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>23、 根据文件格式设置链接图标<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="http:"]</span> &#123;</div><div class="line">        <span class="attribute">display</span>:inline-block;</div><div class="line">        <span class="attribute">padding-right</span>:<span class="number">14px</span>;</div><div class="line">        <span class="attribute">background</span>:transparent <span class="built_in">url</span>(/Images/ExternalLink.gif) center right no-repeat;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="mailto:"]</span> &#123;</div><div class="line">        <span class="attribute">display</span>:inline-block;</div><div class="line">        <span class="attribute">padding-left</span>:<span class="number">20px</span>;</div><div class="line">        <span class="attribute">line-height</span>:<span class="number">18px</span>;</div><div class="line">        <span class="attribute">background</span>:transparent <span class="built_in">url</span>(/Images/MailTo.gif) center left no-repeat;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$='.pdf']</span> &#123;</div><div class="line">        <span class="attribute">display</span>:inline-block;</div><div class="line">        <span class="attribute">padding-left</span>:<span class="number">20px</span>;</div><div class="line">        <span class="attribute">line-height</span>:<span class="number">18px</span>;</div><div class="line">        <span class="attribute">background</span>:transparent <span class="built_in">url</span>(/Images/PDFIcon.gif) center left no-repeat;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$='.swf']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.fla']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.swd']</span> &#123;</div><div class="line">        <span class="attribute">display</span>:inline-block;</div><div class="line">        <span class="attribute">padding-left</span>:<span class="number">20px</span>;</div><div class="line">        <span class="attribute">line-height</span>:<span class="number">18px</span>;</div><div class="line">        <span class="attribute">background</span>:transparent <span class="built_in">url</span>(/Images/FlashIcon.gif) center left no-repeat;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$='.xls']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.csv']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.xlt']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.xlw']</span> &#123;</div><div class="line">        <span class="attribute">display</span>:inline-block;</div><div class="line">        <span class="attribute">padding-left</span>:<span class="number">20px</span>;</div><div class="line">        <span class="attribute">line-height</span>:<span class="number">18px</span>;</div><div class="line">        <span class="attribute">background</span>:transparent <span class="built_in">url</span>(/Images/ExcelIcon.gif) center left no-repeat;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$='.ppt']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.pps']</span> &#123;</div><div class="line">        <span class="attribute">display</span>:inline-block;</div><div class="line">        <span class="attribute">padding-left</span>:<span class="number">20px</span>;</div><div class="line">        <span class="attribute">line-height</span>:<span class="number">18px</span>;</div><div class="line">        <span class="attribute">background</span>:transparent <span class="built_in">url</span>(/Images/PowerPointIcon.gif) center left no-repeat;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$='.doc']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.rtf']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.txt']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.wps']</span> &#123;</div><div class="line">        <span class="attribute">display</span>:inline-block;</div><div class="line">        <span class="attribute">padding-left</span>:<span class="number">20px</span>;</div><div class="line">        <span class="attribute">line-height</span>:<span class="number">18px</span>;</div><div class="line">        <span class="attribute">background</span>:transparent <span class="built_in">url</span>(/Images/WordDocIcon.gif) center left no-repeat;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$='.zip']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.gzip']</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$='.rar']</span> &#123;</div><div class="line">        <span class="attribute">display</span>:inline-block;</div><div class="line">        <span class="attribute">padding-left</span>:<span class="number">20px</span>;</div><div class="line">        <span class="attribute">line-height</span>:<span class="number">18px</span>;</div><div class="line">        <span class="attribute">background</span>:transparent <span class="built_in">url</span>(/Images/ZIPIcon.gif) center left no-repeat;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>24、 在IE浏览器中删除textarea的滚动条<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">textarea</span>&#123;</div><div class="line">    <span class="attribute">overflow</span>:auto;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>25、 段落首字下沉<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-letter</span>&#123;</div><div class="line">    <span class="attribute">display</span>:block;</div><div class="line">    <span class="attribute">margin</span>:<span class="number">5px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</div><div class="line">    <span class="attribute">float</span>:left;</div><div class="line">    <span class="attribute">color</span>:<span class="number">#FF3366</span>;</div><div class="line">    <span class="attribute">font-size</span>:<span class="number">60px</span>;</div><div class="line">    <span class="attribute">font-family</span>:Georgia;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>26、 所有浏览器下的CSS透明度<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.transparent</span> &#123;</div><div class="line">    <span class="comment">/* Fallback for web browsers that doesn't support RGBa */</span></div><div class="line">    <span class="attribute">background</span>: <span class="built_in">rgb</span>(0, 0, 0);</div><div class="line">    <span class="comment">/* RGBa with 0.6 opacity */</span></div><div class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(0, 0, 0, 0.6);</div><div class="line">    <span class="comment">/* For IE 5.5 - 7*/</span></div><div class="line">    <span class="attribute">filter</span>:progid:DXImageTransform.Microsoft.<span class="built_in">gradient</span>(startColorstr=#99000000, endColorstr=#99000000);</div><div class="line">    <span class="comment">/* For IE 8*/</span></div><div class="line">    <span class="attribute">-ms-filter</span>: <span class="string">"progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>27、 图片预加载<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#preloader</span> &#123;<span class="comment">/* 这样当某个元素需要时，他就已经被加载了，此时就不会有任何延误或闪烁的现像：*/</span></div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(image1.jpg);</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(image2.jpg);</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(image3.jpg);</div><div class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>28、 固定页脚<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#footer</span> &#123;</div><div class="line">    <span class="attribute">position</span>:fixed;</div><div class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</div><div class="line">    <span class="attribute">bottom</span>:<span class="number">0px</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">30px</span>;</div><div class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</div><div class="line">    <span class="attribute">background</span>:<span class="number">#999</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* IE 6 */</span></div><div class="line">* <span class="selector-tag">html</span> <span class="selector-id">#footer</span> &#123;</div><div class="line">    <span class="attribute">position</span>:absolute;</div><div class="line">    <span class="attribute">top</span>:<span class="built_in">expression</span>((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+<span class="string">'px'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>29、 翻转图片<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span><span class="selector-class">.flip</span> &#123;</div><div class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">scaleX</span>(-1);</div><div class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">scaleX</span>(-1);</div><div class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">scaleX</span>(-1);</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleX</span>(-1);</div><div class="line">    <span class="attribute">filter</span>: FlipH;</div><div class="line">    <span class="attribute">-ms-filter</span>: <span class="string">"FlipH"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>30、 clearfix<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</div><div class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">line-height</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">display</span>:block;</div><div class="line">    <span class="attribute">visibility</span>:hidden;</div><div class="line">    <span class="attribute">clear</span>:both ;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.clearfix</span>&#123;</div><div class="line">    <span class="attribute">zoom</span>:<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>31、 简单的文字模糊效果<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*&#123; </div><div class="line">    <span class="attribute">color</span>: transparent;</div><div class="line">    <span class="attribute">text-shadow</span>: <span class="number">#111</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>32、 鼠标移进网页里消失<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*&#123;</div><div class="line">    <span class="attribute">cursor</span>: none<span class="meta">!important</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>33、 多重边框<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.div</span> &#123;</div><div class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.2), <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.2), <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">18px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.2), <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">24px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.2);</div><div class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> auto;</div><div class="line">    <span class="attribute">width</span>: <span class="number">400px</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>34、去掉li前面的点<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span>&#123;</div><div class="line">    <span class="attribute">list-style-type</span>:none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>35、去掉a标签下划线<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span>&#123;</div><div class="line">    <span class="attribute">text-decoration</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: css技巧记录&lt;br&gt;date: 2017-12-25 16:00:07&lt;/p&gt;
&lt;h2 id=&quot;tags&quot;&gt;&lt;a href=&quot;#tags&quot; class=&quot;headerlink&quot; title=&quot;tags:&quot;&gt;&lt;/a&gt;tags:&lt;/h2&gt;&lt;p&gt;1、 使
    
    </summary>
    
    
  </entry>
  
</feed>
