<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="sansan.blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="vertial-align,text-aligh对行内元素有效Script Error是外部加载的JS 抛出异常的时候， 出于安全方面的考虑，js错误信息中可能包含一些敏感信息，比如用户名、权限提示等，希望能够把这类信息屏蔽。目前跨域的场景下会触发这种安全限制，window.onerror无法获得具体出错信息，而只能得到Script error.解决ScriptError 问题：响应头增加 acc">
<meta property="og:type" content="article">
<meta property="og:title" content="前端疑惑记录">
<meta property="og:url" content="http://yoursite.com/2018/01/02/前端疑惑记录/index.html">
<meta property="og:site_name" content="sansan.blog">
<meta property="og:description" content="vertial-align,text-aligh对行内元素有效Script Error是外部加载的JS 抛出异常的时候， 出于安全方面的考虑，js错误信息中可能包含一些敏感信息，比如用户名、权限提示等，希望能够把这类信息屏蔽。目前跨域的场景下会触发这种安全限制，window.onerror无法获得具体出错信息，而只能得到Script error.解决ScriptError 问题：响应头增加 acc">
<meta property="og:updated_time" content="2018-04-08T09:37:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端疑惑记录">
<meta name="twitter:description" content="vertial-align,text-aligh对行内元素有效Script Error是外部加载的JS 抛出异常的时候， 出于安全方面的考虑，js错误信息中可能包含一些敏感信息，比如用户名、权限提示等，希望能够把这类信息屏蔽。目前跨域的场景下会触发这种安全限制，window.onerror无法获得具体出错信息，而只能得到Script error.解决ScriptError 问题：响应头增加 acc">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/02/前端疑惑记录/"/>





  <title>前端疑惑记录 | sansan.blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sansan.blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/前端疑惑记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三三">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sansan.blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端疑惑记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T17:58:50+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="vertial-align-text-aligh对行内元素有效"><a href="#vertial-align-text-aligh对行内元素有效" class="headerlink" title="vertial-align,text-aligh对行内元素有效"></a>vertial-align,text-aligh对行内元素有效</h1><h1 id="Script-Error"><a href="#Script-Error" class="headerlink" title="Script Error"></a>Script Error</h1><p>是外部加载的JS 抛出异常的时候， 出于安全方面的考虑，js错误信息中可能包含一些敏感信息，比如用户名、权限提示等，希望能够把这类信息屏蔽。目前跨域的场景下会触发这种安全限制，window.onerror无法获得具体出错信息，而只能得到Script error.<br>解决ScriptError 问题：<br>响应头增加 access-control-allow-orgin （以下简称AC）<br>每个fucntion 包裹 try-catch<br>切面包裹入口函数， try-catch</p>
<h1 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a>“use strict”</h1><p><b>ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）,顾名思义，这种模式使得Javascript在更严格的条件下运行。</b></p>
<ol>
<li>优点<br>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;消除代码运行的一些不安全之处，保证代码运行的安全提高编译器效率，增加运行速度;为未来新版本的Javascript做好铺垫。<br>“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。</li>
<li><p>调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"这是严格模式。"</span>);<span class="comment">/* 针对单个脚本 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">　　　　"use strict"</span>;</div><div class="line">　　　　<span class="keyword">return</span> <span class="string">"这是严格模式。"</span>;</div><div class="line">　　&#125;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">notStrict</span>(<span class="params"></span>) </span>&#123;</div><div class="line">　　　　<span class="keyword">return</span> <span class="string">"这是正常模式。"</span>;</div><div class="line">　　&#125;<span class="comment">/* 针对单个函数 */</span></div></pre></td></tr></table></figure>
</li>
<li><p>语法与行为改变<br>3.1 全局变量显式声明：在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">　　v = <span class="number">1</span>; <span class="comment">// 报错，v未声明</span></div><div class="line">　　<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="comment">// 报错，i未声明</span></div><div class="line">　　&#125;<span class="comment">/* 严格模式下，变量都必须先用var命令声明，然后再使用。 */</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>3.2 禁止this关键字指向全局对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">return</span> !<span class="keyword">this</span>;</div><div class="line">　　&#125; </div><div class="line">　　<span class="comment">// 返回false，因为"this"指向全局对象，"!this"就是false</span></div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; </div><div class="line"><span class="meta">　　　　"use strict"</span>;</div><div class="line">　　　　<span class="keyword">return</span> !<span class="keyword">this</span>;</div><div class="line">　　&#125; </div><div class="line">　　<span class="comment">// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。</span></div></pre></td></tr></table></figure></p>
<p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。<br>3.3 禁止删除变量<br>严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">　　<span class="keyword">var</span> x;</div><div class="line">　　<span class="keyword">delete</span> x; <span class="comment">// 语法错误</span></div><div class="line">　　<span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>, &#123;<span class="string">'x'</span>: &#123;</div><div class="line">　　　　　　<span class="attr">value</span>: <span class="number">1</span>,</div><div class="line">　　　　　　<span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">　　&#125;&#125;);</div><div class="line">　　<span class="keyword">delete</span> o.x; <span class="comment">// 删除成功</span></div></pre></td></tr></table></figure></p>
<p>3.4 对象不能有重名的属性<br>正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">　　<span class="keyword">var</span> o = &#123;</div><div class="line">　　　　<span class="attr">p</span>: <span class="number">1</span>,</div><div class="line">　　　　<span class="attr">p</span>: <span class="number">2</span></div><div class="line">　　&#125;; <span class="comment">// 语法错误</span></div></pre></td></tr></table></figure></p>
<p>3.5 函数不能有重名的参数<br>正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, a, b</span>) </span>&#123; <span class="comment">// 语法错误</span></div><div class="line">　　　　<span class="keyword">return</span> ;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<h1 id="JS原型与原型链"><a href="#JS原型与原型链" class="headerlink" title="JS原型与原型链"></a>JS原型与原型链</h1><p>在JavaScript中,一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象,也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。这样就形成了一条线性的链，我们称之为原型链</p>
<ol>
<li>普通对象与函数对象<br>JavaScript 中，万物皆对象！但对象也是有区别的。分为普通对象和函数对象，Object ，Function 是JS自带的函数对象。凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。</li>
<li>原型对象(原型prototype)<br>在JavaScript 中，每当定义一个对象（函数）时候，对象中都会包含一些预定义的属性。其中函数对象的一个属性就是原型prototype。注：普通对象没有prototype,但有<strong>proto</strong>属性。<br>原型对象其实就是普通对象（Function.prototype除外,它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;; </div><div class="line"><span class="built_in">console</span>.log(f1.prototype) <span class="comment">//f1&#123;&#125; </span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1. prototype) <span class="comment">//Object </span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// Function，这个特殊 </span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype) <span class="comment">// Object </span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>从这句console.log(f1.prototype) //f1 {} 的输出就结果可以看出，f1.prototype就是f1的一个实例对象。就是在f1创建的时候,创建了一个它的实例对象并赋值给它的prototype，基本过程如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> f1(); </div><div class="line">f1. prototype = temp;</div></pre></td></tr></table></figure></p>
<p>所以，Function.prototype为什么是函数对象就迎刃而解了，上文提到凡是new Function ()产生的对象都是函数对象，所以temp1是函数对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> temp1 = <span class="keyword">new</span> <span class="built_in">Function</span> (); </div><div class="line"><span class="built_in">Function</span>.prototype = temp1;</div></pre></td></tr></table></figure></p>
<p><b>原型对象是用来做什么的呢？主要作用是用于继承,共享它所包含的属性和方法</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123; </div><div class="line"><span class="keyword">this</span>.name = name </div><div class="line">&#125;; </div><div class="line">person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name; </div><div class="line">&#125; </div><div class="line"><span class="keyword">var</span> zjh = <span class="keyword">new</span> person(<span class="string">'zhangjiahao'</span>); </div><div class="line">zjh.getName(); <span class="comment">//zhangjiahao</span></div><div class="line"><span class="comment">// 通过给person.prototype设置了一个函数对象的属性，那有person实例（例中：zjh）出来的普通对象就继承了这个属性。</span></div></pre></td></tr></table></figure></p>
<p><b>prototype就是通过调用构造函数而创建的对象实例的原型对象。</b></p>
<ol>
<li>原型链<br>JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<strong>proto</strong>的内置属性，用于指向创建它的函数对象的原型对象prototype。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(zjh.__proto__ === person.prototype) <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>同样，person.prototype对象也有<strong>proto</strong>属性，它指向创建它的函数对象（Object）的prototype<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(person.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>Object.prototype对象也有<strong>proto</strong>属性，但它比较特殊，为null<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">//null</span></div></pre></td></tr></table></figure></p>
<p><b>我们把这个有<strong>proto</strong>串起来的直到Object.prototype.<strong>proto</strong>为null的链叫做原型链</b><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line">animal.price = <span class="number">2000</span>;<span class="comment">//</span></div><div class="line">dog.prototype = animal;</div><div class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(dog.price) <span class="comment">//为什么输出 undefined </span></div><div class="line"><span class="built_in">console</span>.log(tidy.price) <span class="comment">//为什么输出 2000</span></div><div class="line"><span class="comment">/* dog是函数对象，自生没有price属性，dog的__proto__是构造函数的prototype，为new Function()的prototype，Function()的prototype没有price属性所以undefined；</span></div><div class="line"> tidy是普通对象，自生没有price属性，tidy的__proto__是构造函数的prototype，为new dog()的prototype，dog的prototype为animal，而animal有price属性所以为2000.*/</div></pre></td></tr></table></figure></p>
<p><b>当在自生找不到某个属性或方法时，会在<strong>proto</strong>寻找原型上的属性或方法</b></p>
<h1 id="JavaScript的函数currying柯里化"><a href="#JavaScript的函数currying柯里化" class="headerlink" title="JavaScript的函数currying柯里化"></a>JavaScript的函数currying柯里化</h1><p><b>柯里化是指将使用多个参数的函数转换成一系列使用一个参数的函数的技术。</b><br>通用版本:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _args = [];</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">Array</span>.prototype.push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</div><div class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> multi=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/* 简单应用 */</span></div><div class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, c; c = <span class="built_in">arguments</span>[i++];) &#123;</div><div class="line">        total += c;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> total;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> sum = currying(multi);  </div><div class="line">sum(<span class="number">100</span>,<span class="number">200</span>)(<span class="number">300</span>);</div><div class="line">sum(<span class="number">400</span>);</div><div class="line"><span class="built_in">console</span>.log(sum());     <span class="comment">// 1000  （空白调用时才真正计算）</span></div></pre></td></tr></table></figure></p>
<p>prototype 属性,这是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fun = <span class="built_in">Function</span>.prototype.bind()<span class="comment">// 这个函数是不具有 prototype 属性</span></div></pre></td></tr></table></figure></p>
<p>prototype(显式原型):当我们声明一个函数时，这个属性就被自动创建,并且这个属性的值是一个对象（也就是原型），只有一个属性 constructor,constructor 对应着构造函数，也就是 Foo。<br><em>proto</em>(隐式原型):每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 <em>proto</em> 来访问。因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 <em>proto</em> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。<br>new 的过程：</p>
<ol>
<li>新生成一个对象；</li>
<li>链接到原型；</li>
<li>绑定this；</li>
<li>返回新对象。</li>
</ol>
<h1 id="理解CSS中BFC-Block-Formatting-Context-块格式化上下文"><a href="#理解CSS中BFC-Block-Formatting-Context-块格式化上下文" class="headerlink" title="理解CSS中BFC(Block Formatting Context:块格式化上下文)"></a>理解CSS中BFC(Block Formatting Context:块格式化上下文)</h1><p><b>BFC是Web页面中盒模型布局的CSS渲染模式。它的定位体系属于常规文档流。</b></p>
<ol>
<li>触发BFC<br>根元素，浮动，绝对定位元素，inline-blocks, table-cells, table-captions,flex,inline-flex,和overflow的值不为visible的元素，（除了这个值已经被传到了视口的时候）将创建一个新的块级格式化上下文。<br><b>创建一个新的BFC的最佳方案：”overflow: hidden”</b></li>
<li>BFC导致的外边距折叠<br>BFC里：理论上两个兄弟元素之间的边距应该是来两个元素的边距之和（20px），但它实际上为10px。这就是被称为外边距折叠。当兄弟元素的外边距不一样时，将以最大的那个外边距为准。当然垂直外边距折叠只有他们是在同一BFC时才会发生</li>
<li>使用BFC来防止外边距折叠<br>如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Sibling 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Sibling 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"newBFC"</span>&gt;</span> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Sibling 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">background-color</span>: red; <span class="attribute">overflow</span>: hidden; <span class="comment">/* creates a block formatting context */</span> &#125; </div><div class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>; <span class="attribute">background-color</span>: lightgreen; &#125; </div><div class="line"><span class="selector-class">.newBFC</span> &#123; <span class="attribute">overflow</span>: hidden; <span class="comment">/* creates new block formatting context */</span> &#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>使用BFC来包含浮动<br>一个容器里有浮动元素。由于这个原因，容器元素没有高度，它的浮动孩子将会脱离页面的常规流。我们通常使用清除浮动来解决这个问题，最受欢迎的方法是使用一个clearfix的伪类元素。但我们同样可以通过定义一个BFC来达到这个目的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">overflow</span>: hidden; <span class="comment">/* creates block formatting context */</span> <span class="attribute">background-color</span>: green; &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用BFC来防止文字环绕</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"floated"</span>&gt;</span>Floated div<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Quae hic ut ab perferendis sit quod architecto,dolor debitis quam rem provident aspernatur tempora expedita.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">overflow</span>: hidden;&#125;</div></pre></td></tr></table></figure>
<h1 id="TCP协议中的三次握手和四次挥手"><a href="#TCP协议中的三次握手和四次挥手" class="headerlink" title="TCP协议中的三次握手和四次挥手"></a>TCP协议中的三次握手和四次挥手</h1><p><b>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号 并交换 TCP窗口大小信息。</b></p>
<ol>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x;然后，客户端进入SYN_SEND状态，等待服务器的确认;</li>
<li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1);同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态;</li>
<li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br><b>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。</b></li>
<li>第一次挥手：主机1(可以使客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段;此时，主机1进入FIN_WAIT_1状态;这表示主机1没有数据要发送给主机2了;</li>
<li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1;主机1进入FIN_WAIT_2状态;主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了;</li>
<li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态;</li>
<li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。<h1 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h1>https是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</li>
<li>HTTP 是不安全的，而 HTTPS 是安全的</li>
<li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li>
<li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 工作在传输层</li>
<li>HTTP 无法加密，而HTTPS 对传输的数据进行加密</li>
<li>HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书</li>
</ol>
<h1 id="setTimeout-和setInterval"><a href="#setTimeout-和setInterval" class="headerlink" title="setTimeout()和setInterval()"></a>setTimeout()和setInterval()</h1><p>setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式；而setInterval()则可以在每隔指定的毫秒数<b>循环</b>调用函数或表达式，直到clearInterval把它清除。<br>setTimeout(code,millisec)、setInterval(code,millisec[,”lang”])<br>setInterval只要一次计时完毕，插入回调之后不管回调执不执行就开始计时，这会出现一种情况，当我们插入回调的时候前队列有别的代码在执行。setInterval如果第一个函数的执行时间特别长，在执行的过程中本应触发了许多个func，这些func并不会都进入队列，只要发现队列中有一个被执行的函数存在，那么其他的统统忽略。<b>在setInterval的里指定的周期是100毫秒，但它并不能保证两个函数之间调用的间隔一定是一百毫秒。<b><br>保证每次执行的间隔相同：用setTimeout</b></b></p>
<h1 id="js中的栈-堆和基本数据类型-引用类型"><a href="#js中的栈-堆和基本数据类型-引用类型" class="headerlink" title="js中的栈/堆和基本数据类型/引用类型"></a>js中的栈/堆和基本数据类型/引用类型</h1><ol>
<li>栈(stack)与堆(heap)<br>stack为自动分配的内存空间，由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。</li>
<li>基本类型与引用类型</li>
</ol>
<ul>
<li><b>基本类型：</b>存放在栈内存中的简单数据段，数据大小可以确定，内存空间大小可以分配；<br>五种基本数据类型有：undefined、Number、String、Boolean、Null，它们都是按值存放，所以可以直接访问。</li>
<li><b>引用类型：</b>存放在堆内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。每个空间大小不一样，要根据情况进行特定的分配。<br>当我们需要访问引用类型（对象、数组、函数等）时，首先从栈中获得该对象的地址指针，然后再从堆内存中访问所需数据。</li>
</ul>
<ol>
<li>传值与传址<br>基本类型与引用类型最大的区别是传值与传址的区别。</li>
</ol>
<ul>
<li>浅拷贝<br>在定义一个对象或数组时，变量存放的往往只是一个地址。当我们使用对象拷贝时，如果属性是对象或数组时，这时候我们传递的也只是一个地址。因此子对象在访问该属性时，会根据地址回溯到父对象指向的堆内存中，即父子对象发生了关联，两者的属性值会指向同一内存空间。</li>
<li>深拷贝<br>我们不希望父子对象之间产生关联，那么这时候可以用到深拷贝。既然属性值类型是数组和或象时只会传址，那么我们就用递归来解决这个问题，把父对象中所有属于对象的属性类型都遍历赋给子对象即可。</li>
</ul>
<h1 id="浏览器缓存知识总结"><a href="#浏览器缓存知识总结" class="headerlink" title="浏览器缓存知识总结"></a>浏览器缓存知识总结</h1><p>浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数web开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。</p>
<h2 id="浏览器缓存基本认识"><a href="#浏览器缓存基本认识" class="headerlink" title="浏览器缓存基本认识"></a>浏览器缓存基本认识</h2><p>浏览器缓存分为强缓存和协商缓存：</p>
<ol>
<li>浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；</li>
<li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</li>
<li>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</li>
<li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</li>
</ol>
<h2 id="强缓存的原理"><a href="#强缓存的原理" class="headerlink" title="强缓存的原理"></a>强缓存的原理</h2><p>当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache。强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。<br>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新；</li>
</ol>
<p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header；</li>
<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</li>
<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；</li>
<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</li>
</ol>
<p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。</p>
<h2 id="强缓存的管理"><a href="#强缓存的管理" class="headerlink" title="强缓存的管理"></a>强缓存的管理</h2><p>在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存：</p>
<ol>
<li>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li>
<li>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</li>
</ol>
<p>开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：</p>
<ol>
<li>直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；</li>
<li>使用浏览器的隐私模式开发；</li>
<li>如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）；</li>
<li>在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；</li>
<li>如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面；</li>
<li>如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数；</li>
<li>还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题；</li>
<li>如果你用的是grunt和gulp这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存。</li>
</ol>
<h2 id="强缓存的应用"><a href="#强缓存的应用" class="headerlink" title="强缓存的应用"></a>强缓存的应用</h2><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年。<br>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。不过现在已经有很多前端工具能够实际地解决这个问题。</p>
<h2 id="协商缓存的原理"><a href="#协商缓存的原理" class="headerlink" title="协商缓存的原理"></a>协商缓存的原理</h2><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。<br>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。<br>【Last-Modified，If-Modified-Since】的控制缓存的原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间；</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值；</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header；</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源；</li>
<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值；</li>
</ol>
<p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题;</li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值;</li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化;</li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
</ol>
<h2 id="协商缓存的管理"><a href="#协商缓存的管理" class="headerlink" title="协商缓存的管理"></a>协商缓存的管理</h2><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache。<br>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：</p>
<ol>
<li>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</li>
<li>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）。</li>
</ol>
<p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>
<h2 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h2><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变。</p>
<ol>
<li>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当f5刷新网页时，跳过强缓存，但是会检查协商缓存。</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/27/css3新特性最佳实践/" rel="next" title="css3新特性最佳实践">
                <i class="fa fa-chevron-left"></i> css3新特性最佳实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/05/WebStorm-使用技巧/" rel="prev" title="WebStorm 使用技巧">
                WebStorm 使用技巧 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="三三" />
          <p class="site-author-name" itemprop="name">三三</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/sansansine" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/sansansine" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#vertial-align-text-aligh对行内元素有效"><span class="nav-number">1.</span> <span class="nav-text">vertial-align,text-aligh对行内元素有效</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Script-Error"><span class="nav-number">2.</span> <span class="nav-text">Script Error</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#“use-strict”"><span class="nav-number">3.</span> <span class="nav-text">“use strict”</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS原型与原型链"><span class="nav-number">4.</span> <span class="nav-text">JS原型与原型链</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript的函数currying柯里化"><span class="nav-number">5.</span> <span class="nav-text">JavaScript的函数currying柯里化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解CSS中BFC-Block-Formatting-Context-块格式化上下文"><span class="nav-number">6.</span> <span class="nav-text">理解CSS中BFC(Block Formatting Context:块格式化上下文)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP协议中的三次握手和四次挥手"><span class="nav-number">7.</span> <span class="nav-text">TCP协议中的三次握手和四次挥手</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http与https"><span class="nav-number">8.</span> <span class="nav-text">http与https</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#setTimeout-和setInterval"><span class="nav-number">9.</span> <span class="nav-text">setTimeout()和setInterval()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js中的栈-堆和基本数据类型-引用类型"><span class="nav-number">10.</span> <span class="nav-text">js中的栈/堆和基本数据类型/引用类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浏览器缓存知识总结"><span class="nav-number">11.</span> <span class="nav-text">浏览器缓存知识总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器缓存基本认识"><span class="nav-number">11.1.</span> <span class="nav-text">浏览器缓存基本认识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强缓存的原理"><span class="nav-number">11.2.</span> <span class="nav-text">强缓存的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强缓存的管理"><span class="nav-number">11.3.</span> <span class="nav-text">强缓存的管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强缓存的应用"><span class="nav-number">11.4.</span> <span class="nav-text">强缓存的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协商缓存的原理"><span class="nav-number">11.5.</span> <span class="nav-text">协商缓存的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协商缓存的管理"><span class="nav-number">11.6.</span> <span class="nav-text">协商缓存的管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器行为对缓存的影响"><span class="nav-number">11.7.</span> <span class="nav-text">浏览器行为对缓存的影响</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Powered By-三三</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 个人
</div>

<div class="theme-info">
  博客 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  


  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

</body>
</html>
